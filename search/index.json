[{"content":"从我毕业进入公司起，负责人就一直在提及一点：「编程不仅仅是知识和技能，更重要的是去领会编程领域的文化」。刚进入公司的我似乎并没有马上接受这一点，认为这可能只是所谓的 “玄学” 罢了，所以也就是当作任务记下了，并没有很好的理会。\n直到我工作了一年后，疫情期间读完负责人发来的一篇《如何成为一名黑客》，文章似乎解答了我初入编程行业的疑惑并且指明了未来的方向。\n标题是如何成为一名黑客，这里的黑客并不是我们所认为的在网络中来无影去无踪的 “黑客”。在我看来，这篇文章讲述的是你如何成为一名优秀并且受人尊敬的计算机工程师。\n基本的态度  这个世界充满了令人着迷的问题等着我们去解决  你要从解决问题，磨练技术，以及锻炼智力中得到基本的享受以及动力。的确，回想这一年的工作时光，另我开心的事情莫过于解决了棘手问题，学习了一门新的语言，自己完成的功能第二天就上线，得到了客户的认可等等。\n一个问题不应该被解决两次  不应该把宝贵的时间浪费在发明轮子上。初入公司我想着把很多 python2 的代码重构成 python3，现在想想确实浪费时间，应该着重于解决新的问题而不是在旧问题上浪费时间。\n无聊和乏味的工作是罪恶的  重复性劳动浪费我们解决新问题的时间，而解决新问题才是最大的价值所在。提取公共函数，将日常的工作变成自动化等等。\n崇尚自由  其实这一点并不是很理解，产品经理提出无理的需求？？？\n2020/09/10 更新：这个上升到政治层面就比较好理解了，比如美国打压 WeChat 和 Tik Tok\n态度不能代替能力  只具备这些态度并不能使你成为一名黑客，也不能使你成为一个运动健将和摇滚明星。成为一名黑客需要智力、实践、奉献精神、以及辛苦的工作。\n基本的技能  学习如何编程（这里包括以下内容有几句话写的很好，我想全搬运过来）  有一个大体的规律，就是如果你过于偏重使用一种语言，这种语言一方面会成为你得心应手的工具，另一方面也会阻碍你的学习。有这个问题的不只是编程语言，类似 RubyOnRails、CakePHP、以及 Django 的 web 应用框架也有这个问题，它们只会让你肤浅地懂得一些东西，当你碰到难以解决的问题或者需要调试时，你就可能不知所措了。\n单单学习编程语言并不会让你达到黑客的程度，甚至连程序员的程度都难企及——你需要脱离某种编程语言的束缚，学习通过编程解决问题的思路。要成为一个真正的黑客，你需要达到几天就能学会一门编程语言的水平，你可以将文档里的信息和你已经掌握的知识结合起来，很快就学会一门编程语言。这意味着你需要先学会机种思路截然不同的语言才行。\n编程是一个复杂的技能，我无法给你完整的指南来教会你如何编程，不过我可以告诉你，书本和课程也无法教会你如何编程——很多黑客，或者也许几乎所有的黑客，都是靠自学的。你从书本上学到语言的特点——只是一些皮毛，但要使书面知识成为自身技能，你只能通过实践和虚心向他人学习。因此你要做的就是 (a) 读代码，(b) 写代码。\n学习编程就象学习自然语言写作一样。最好的做法是读一些大师的名著，试着自己写点东西，再读些，再写点，再读些，再写点…… 如此往复，直到你的文章具备范文的力量和感觉为止。\n学会使用开源的 Unix 系统  Unix 还是 Internet 的操作系统。你可以学会上网却不知道 Unix，但你不了解 Unix 就无法成为一名 Internet 黑客。因此，今天的黑客文化在很大程度上是以 Unix 为核心的。（这点并不总是真的，一些很早的黑客对此一直很不满，但 Unix 和 Internet 之间的联系已是如此之强，就连 Microsoft 这样强力的公司也对此也无可奈何。）\n学会使用万维网以及编写 HTML  学会使用 Google，Stack Overflow，Github 等等\n学习英语，如果你的水平不够的话  Linus Torvalds 是芬兰人，但他的代码注解是用英语写的（很明显他从没想过其他的可能性）。他流利的英语。是他能够管理全球范围的 Linux 开发人员社区的重要因素，这是一个值得学习的例子。\n就算你的母语是英语，这也无法保证你的语言技能足够达到黑客的标准。如果你的写作文字不通、语法混乱、错字连篇，包括我在内的大部分的黑客都会忽略你的存在。虽然写作马虎不一定意味着思考也马虎，但我们发现两者的关联性还是挺强的——马虎的头脑对我们来说毫无价值，如果你写作能力不够，就好好学习写作吧。（划重点，终于知道王哥为什么每次都会特别强调然后纠正我的错别字了）\n提高自己在编程圈中的地位 以下就是以后的人生所追求的吧，自己离这些还很遥远。\n 撰写开源软件  黑客领域里最受尊敬的偶像，是那些写了大型的、好用的、用途广泛的软件，并把它们发布出来，使得每人都在使用他软件的人。\n帮助测试并调试开源软件  如果你是个新手，试着找一个你感兴趣的正在开发中的程序，做一个好的 beta 测试员。你会自然地从帮着测试，进步到帮着抓 bug，到最后帮着改程序。你会从中学到很多，而且善因种善果，以后别人也会很乐意帮助你。\n发布有用的信息  另一件好事是收集整理有用有趣的信息，做成网页或类似 FAQ 的文档，并且让大家都能看到。技术性 FAQ 的维护者会受到和开源代码的作者一样多的尊敬。（比如 Github 上面很多 awesome language 和国内很多大佬的博客，录制的教程等等）\n帮助维护基础设施的运转  黑客文化（还有互联网工程方面的发展）是靠志愿者推动的。要使 Internet 能正常工作，就要有大量枯燥的工作不得不去完成——管理邮件列表和新闻组，维护大型软件库，开发 RFC 和其它技术标准等等。\n做这类事情的人会得到很多尊敬，因为每人都知道这些事情费时颇多，而又不象编程那样有趣。做这些事情需要奉献精神。\n为黑客文化本身服务  黑客文化没有领袖，这点是确认无疑的。但黑客圈里确实有些文化英雄、部落长者、史学家、还有发言人。如果你在这圈里呆足够长时间，你也许也能成为其中之一。 记住：黑客们不相信他们的部落长者的自夸，因此过分追求这种名誉是危险的。与其奋力追求，不如先摆正自己的位置，等它自己落到你的手中——那时则要做到谦虚和优雅。\n常读常新，每隔一段时间读一遍都会有新的收获。最后附上这篇文档。\n 如何成为一名黑客\n ","date":"2020-04-06T00:00:00Z","permalink":"https://aladdinding.cn/post/%E8%AF%BB%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E9%BB%91%E5%AE%A2%E6%9C%89%E6%84%9F/","title":"读《如何成为一名黑客》有感"},{"content":" 结构型模式介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效\n 适配器 桥接 组合  组合模式是一种结构型设计模式，你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们。\n 在组合模式中，无论是复杂的还是简单的对象共用一个接口。在这个统一接口的帮助下，客户端不必在意其对象的具体类\n装饰  装饰模式是一种结构型设计模式，允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  package main import \u0026#34;fmt\u0026#34; type drink interface { getPrice() int } type coffee struct { } func (c *coffee) getPrice() int { return 20 } type addMilk struct { drink drink } func (add *addMilk) getPrice() int { drinkPrice := add.drink.getPrice() return drinkPrice + 5 } type addSugar struct { drink drink } func (add *addSugar) getPrice() int { drinkPrice := add.drink.getPrice() return drinkPrice + 2 } func main() { coffee := \u0026amp;coffee{} // add milk \tcoffeeWithMilk := \u0026amp;addMilk{drink: coffee} // add sugar \tcoffeeWithMilkAndSugar := \u0026amp;addSugar{drink: coffeeWithMilk} fmt.Printf(\u0026#34;The drink price is %d\u0026#34;, coffeeWithMilkAndSugar.getPrice()) }   很多饮料都能都加糖或者是加牛奶，如果有一天牛奶涨价，需要加10块钱\n那么就只需要改动addMilk中的价格了\n外观  外观模式是一种结构型设计模式，能为程序库、框架或者其他复杂类提供一个简单\n 享元 摒弃了在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，让你能在有限的内存容量中载入更多对象。\n代理  让你能够提供对象的替代品或者其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。\n 代理对象拥有和服务对象相同的接口，它能够提供真实服务对象的替代品给客户端使用。代理接收客户端的请求并进行一些处理（访问控制和缓存等），然后再将请求传递给服务对象。\n最常见的例子就是nginx，或者是一些数据库的proxy了，代理能够进行访问控制、缓存结果、记录日志等功能。\n","date":"2022-05-06T00:00:00Z","permalink":"https://aladdinding.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/","title":"设计模式之结构型模式"},{"content":".gitignore 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  # vim *.swp *.swo *.so # vim plugin # https://github.com/tpope/vim-projectionist .projections.json # TOOD file TODO.md TODO.txt todo.md todo.txt # python .ropeproject/ *.pyc *.pyo # testfile run_admin.sh wnntest.sh wnnrun.sh wnntodo.md run.sh .python-version .tmp # mvn mvn_publish.sh # js/node .tern-port .tern-project t.js node_modules/ # ag silver searcher .agignore # IDE .idea # mac .DS_Store # personal mydoc # golang .gometalinter.json .netrwhist # redis dump.rdb   Commit 模版 1 2 3 4 5 6 7 8 9 10 11 12 13 14  # head: \u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt; # - type: feat, fix, docs, style, refactor, test, chore # - scope: can be empty (eg. if the change is a global or difficult to assign to a single component) # - subject: start with verb (such as \u0026#39;change\u0026#39;), 50-character line # # body: 72-character wrapped. This should answer: # * Why was this change necessary? # * How does it address the problem? # * Are there any side effects? # # footer: # - Include a link to the ticket, if any. # - BREAKING CHANGE #   ","date":"2022-04-24T00:00:00Z","permalink":"https://aladdinding.cn/post/git%E5%B8%B8%E7%94%A8%E6%A8%A1%E7%89%88%E6%96%87%E4%BB%B6/","title":"Git常用模版文件"},{"content":" Git Documentation\nGit 教程 - 廖雪峰\n Git 常用命令  git init 初始化本地 git 环境 git clone \u0026lt;repository\u0026gt; 克隆一份代码到本地仓库 git pull 把远程仓库代码更新到本地，等于 git fetch + git merge git pull --rebase origin master 强制把远程仓库的代码更新到当前分支上面 git fetch 把远程库的代码更新到本地 git add . 把本地改动过的文件添加到暂存区中 git commit -m '\u0026lt;commit message\u0026gt;' 把暂存区中的修改提交到本地库 git push 把本地库的修改提交到远程库中 git push origin \u0026lt;branch name\u0026gt; 提交一个分支到远程库中 git branch -r/-a 查看远程分支 / 全部分支 git checkout master/bugfix 切换到某个分支 git checkout -b bugfix 新建 bugfix 分支 git checkout -d bugfix 删除 bugfix 分支 git merge master 假设当前在 bugfix 分支上，把 master 分支上的修改同步到 bugfix 分支上 git merge tool 调用 merge 工具 git stash 把未完成的修改保存起来 git stash list 查看所有保存列表 git stash pop 恢复本地分支到缓存状态 git blame \u0026lt;file name\u0026gt; 查看某个文件每一行的修改记录，谁在什么时候修改的 git status 查看当前分支有哪些修改 git log 查看当前分支上面的日志信息 git diff 查看当前没有 add 的内容 git diff --cached 查看已经 add 但是没有 commit 的内容 git diff HEAD 上面两个命令显示内容的合并 git reset --hard HEAD 撤销本地修改  团队协作 Git 流程 克隆新项目，完成功能并提交  git clone \u0026lt;repository\u0026gt; 克隆代码仓库 git checkout -b \u0026lt;branch name\u0026gt; 新建分支 \u0026lt;modify your code\u0026gt; 完成功能的开发，代码的修改 git add . 把修改添加到暂存区 git commit -m '\u0026lt;commit message\u0026gt;' 提交修改到 bugfix 分支 \u0026lt;review 代码\u0026gt; git checkout master 切换到 master 分支 git pull 更新代码 git merge \u0026lt;branch name\u0026gt; 将新建分支合并到 master git push origin \u0026lt;branch name\u0026gt; 把新建分支的代码 push 到远程仓库  正在新功能分支开发，需要紧急修复 bug 适用于新功能正在开发还不想提交的情况\n因为工作区和暂存区的内容是公共的，不属于任何一个分支，所以就需要git stash临时保存修改\n git add . 将当前代码添加暂存 git stash 保存修改 git checkout -b \u0026lt;bugfix\u0026gt; 新建 bugfix 分支 git pull --rebase origin master 主分支代码更新到当前分支 \u0026lt;fix the bug\u0026gt; 修复 bug git add . 添加暂存 git commit -m '\u0026lt;commit message\u0026gt;' 提交代码 git push origin \u0026lt;bugfix\u0026gt; 推动 bugfix 分支到远程仓库 git checkout \u0026lt;new feature branch\u0026gt; 回到新功能开发分支 git stash pop 恢复修改 \u0026lt;continue develop\u0026gt; 继续开发  ","date":"2022-04-21T00:00:00Z","permalink":"https://aladdinding.cn/post/git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/","title":"Git 常用命令总结"},{"content":"在使用 Python Web 框架 Django 本地 runserver 启动后修改了代码，程序够自动重新加载并执行（live-reload），在开发调试阶段非常实用，可以提高开发效率。\n在使用 Go 开发自己的项目或者使用 gin 框架进行本地调试的时候，也需要在文件修改后自动编译运行查看效果，那么则可以使用 air 这个工具。\nAIR air 使用 go 语言开发，可以实现 go 语言应用程序的热加载，它支持以下特性：\n 彩色日志输出 自定义构建或二进制命令 支持忽略子目录 启动后支持监听新目录 更好的构建流程  安装 由于是 go 语言开发，对于我来说就直接下载二进制文件放到系统 PATH 目录下了，当然也可以使用 go get 、Docker 等方式安装，具体可以查看 Readme 中其他的安装方法，这里就不再赘述了\n使用 写好 .air.conf 文件放在项目目录下然后直接执行 air 命令就行，非常简单\n完整的示例以及注释如下，需要新增环境变量或者是命令行参数的可以在 full_bin 前后添加\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  # [Air](https://github.com/cosmtrek/air) TOML 格式的配置文件 # 工作目录 # 使用 . 或绝对路径，请注意 `tmp_dir` 目录必须在 `root` 目录下 root = \u0026#34;.\u0026#34; tmp_dir = \u0026#34;tmp\u0026#34; [build] # 只需要写你平常编译使用的 shell 命令。你也可以使用 `make` cmd = \u0026#34;go build -o ./tmp/main .\u0026#34; # 由 `cmd` 命令得到的二进制文件名 bin = \u0026#34;tmp/main\u0026#34; # 自定义的二进制，可以在前方添加环境变量或者是后方添加命令行参数启动 eg：APP_ENV=dev full_bin = \u0026#34;./tmp/main\u0026#34; # 监听以下文件扩展名的文件。 include_ext = [\u0026#34;go\u0026#34;, \u0026#34;tpl\u0026#34;, \u0026#34;tmpl\u0026#34;, \u0026#34;html\u0026#34;] # 忽略这些文件扩展名或目录 exclude_dir = [\u0026#34;assets\u0026#34;, \u0026#34;tmp\u0026#34;, \u0026#34;vendor\u0026#34;, \u0026#34;frontend/node_modules\u0026#34;] # 监听以下指定目录的文件 include_dir = [] # 排除以下文件 exclude_file = [] # 如果文件更改过于频繁，则没有必要在每次更改时都触发构建。可以设置触发构建的延迟时间 delay = 1000 # ms # 发生构建错误时，停止运行旧的二进制文件。 stop_on_error = true # air 的日志文件名，该日志文件放置在你的 `tmp_dir` 中 log = \u0026#34;air_errors.log\u0026#34; [log] # 显示日志时间 time = true [color] # 自定义每个部分显示的颜色。如果找不到颜色，使用原始的应用程序日志。 main = \u0026#34;magenta\u0026#34; watcher = \u0026#34;cyan\u0026#34; build = \u0026#34;yellow\u0026#34; runner = \u0026#34;green\u0026#34; [misc] # 退出时删除 tmp 目录 clean_on_exit = true   生成并运行的二进制文件会放在当前目录下 tmp 目录，程序结束后会自动删除，非常贴心\n","date":"2022-04-21T00:00:00Z","permalink":"https://aladdinding.cn/post/%E4%BD%BF%E7%94%A8-air-%E5%AE%9E%E7%8E%B0-go-%E7%A8%8B%E5%BA%8F%E7%83%AD%E5%8A%A0%E8%BD%BD/","title":"使用 air 实现 go 程序热加载"},{"content":"经常看到一些 Python 第三方库的 features 中都写到了 Thread safety（线程安全），那么究竟什么是线程安全呢？\n线程不安全 首先看看线程不安全的情况，下面一段代码开启的了两个线程，对全局变量 number 自增 100 万次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  from threading import Thread number = 0 def target(): global number for _ in range(1000000): number += 1 thread_01 = Thread(target=target) thread_02 = Thread(target=target) thread_01.start() thread_02.start() thread_01.join() thread_02.join() print(number)   1 2 3  1476577 1134416 1437371   连续输出多次发现结果并不是我们想要的 200 万，这就是线程不安全。究其原因就是 number+=1 这段代码不是原子操作\n原子操作 原子操作（atomic operation），指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会切换到其他线程，有点类似数据库中的事务。\n在 Python 的 官方文档 中就列出了哪些操作是原子操作（L、L1、L2 是列表，D、D1、D2 是字典，x、y 是对象，i、j 是 int）\n1 2 3 4 5 6 7 8 9 10 11  L.append(x) L1.extend(L2) x = L[i] x = L.pop() L1 [i:j] = L2 L.sort() x = y x.field = y D[x] = y D1.update(D2) D.keys()   这些操作不是\n1 2 3 4  i = i + 1 L.append(L[-1]) L [i] = L[j] D [x] = D[x] + 1   两个线程同时读取到了同一个 number 值完成自增操作后然后赋值，本来已经加两次的操作却只增加了一次。\ndis 模块 当我们还是无法确定我们的代码是否具有原子性的时候，可以尝试通过 dis（Python 字节码反汇编器） 模块里的 dis 函数来查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026gt;\u0026gt;\u0026gt; from dis import dis \u0026gt;\u0026gt;\u0026gt; number = 0 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; def target(): ... global number ... number += 1 ... \u0026gt;\u0026gt;\u0026gt; dis(target) 3 0 LOAD_GLOBAL 0 (number) 2 LOAD_CONST 1 (1) 4 INPLACE_ADD 6 STORE_GLOBAL 0 (number) 8 LOAD_CONST 0 (None) 10 RETURN_VALUE   可以发现 numver += 1 这一行代码是由 4 条字节码实现的，其他字节码可以查看 Python 字节码说明\n LOAD_GLOBAL：加载全局变量 number LOAD_CONST：加载被加数 1 INPLACE_ADD：将两个值相加 STORE_GLOBAL：相加后的结果重新赋值给 number  当一行代码被分成多条字节码指令的时候，就代表在线程线程切换时，有可能只执行了一条字节码指令，此时若这行代码里有被多个线程共享的变量或资源时，并且拆分的多条指令里有对于这个共享变量的写操作，就会发生数据的冲突，导致数据的不准确。\n其实一个操作是不是原子的有两种评判标准（个人理解）：\n 对于纯 Python 代码，是不是只有一条 bytecode 对于 C 实现的函数，内部有没有释放 GIL（如内置数据类型 ints, lists, dicts, etc 的一些操作）  如何线程安全 可以使用 Python 的 threading 模块提供的三种消息通信机制\n Event Condition Queue  如 urllib3 中实现的连接池就使用了 Queue 中的 LifoQueue 来实现线程安全\n疑问 Python 中有 GIL 了为什么还会出现线程不安全呢？ GIL 的作用是：对于一个解释器，只能有一个 thread 在执行 bytecode。所以每时每刻只有一条 bytecode 在被执行一个 thread。GIL 保证了 bytecode 这层面上是 thread safe 的。\n但是如果你有个操作比如 x += 1，这个操作需要多个 bytecodes 操作，在执行这个操作的多条 bytecodes 期间的时候可能中途就换 thread 了，这样就出现了 data races 的情况了。\nPython 中 list 操作是线程安全为什么还要使用 Queue 呢？ 列表操作确实是线程安全的，可以用作多线程中存储对象。但是一般不用列表，而是使用 Queue，因为后者内部实现了 Condition 锁的通信机制，能保证顺序等等。\n参考 https://stackoverflow.com/questions/6319207/are-lists-thread-safe\nhttps://www.zoulei.net/2016/07/31/list_dict_threading_safe/\nhttps://www.cnblogs.com/wongbingming/p/9035579.html\nhttps://zhuanlan.zhihu.com/p/34150765\n","date":"2022-04-19T00:00:00Z","permalink":"https://aladdinding.cn/post/python-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/","title":"Python 中的线程安全和原子操作"},{"content":"入园以后先获取园区地图和当天各个表演的时间，合理安排游玩路线\n必看表演  狂欢大巡游（全园区的大迅游，上午下午各一次，特别热闹） 功夫山庄（动物表演，有海象、海豹、水獭等，建议提前10分钟占好位置） 极地奇缘（海豚表演剧场，建议提前10分钟占好位置） 白鲸之恋（白鲸与饲养员的互动） 人鱼华尔兹（美人鱼演员表演）  各展厅推荐游览方案   企鹅展厅 一定要在企鹅喂食的时间观看，喂食过程很好玩，而且吃完东西的企鹅很活泼，到处跑到处游\n  白鲸展厅 请务必17点以后去一趟白鲸展厅，那个时候大部分游客都已经玩累了出园回家了，你可以一个人享受整个白鲸展厅，这个时候你会看到不一样的白鲸，强烈推荐！！！\n  海底两万里 这里也建议17点以后再去一趟，体验一下一个人的海底，才能值回票价！\n  总结 17点以后的海洋公园才是最好玩的海洋公园，不到清场不要离开园区！我入园的时候比较晚，下午2点才入园，以为体验会很赶，但是17点以后的白鲸馆和海底两万里让我感觉赚了！表演尽量都看完，合理安排时间，不要走马观花，多停留一段时间可以看到不一样的场景。\n","date":"2022-04-04T00:00:00Z","permalink":"https://aladdinding.cn/post/%E6%AD%A6%E6%B1%89%E6%B5%B7%E6%98%8C%E6%9E%81%E5%9C%B0%E6%B5%B7%E6%B4%8B%E4%B8%96%E7%95%8C%E6%B8%B8%E7%8E%A9tips/","title":"武汉海昌极地海洋世界游玩tips"},{"content":" Whatever platform or language you work with, JetBrains has a development tool for you.\n JetBrains 旗下的 IDE 不论是界面布局还是快捷键等都是通用的，所以掌握好 JetBrains 下产品的使用技巧还是非常值得的。\n教程 JetBrains 自家产品的帮助中心已经非常完善了\nJetBrains Product Documentation\n以 PyCharm 举例，用户界面描述：\n Editor 编辑 Action indicators and action list 行动指标和行动清单 Navigation bar 导航栏 Status bar 状态栏 Tool windows 工具窗口 Context menus 上下文菜单 Popup menus 弹出菜单 Main window 主窗口  其他产品的用户界面类似，具体的也可以去文档中心中查看\n破解\u0026amp;白嫖 正常情况下 JetBrains 公司的每个 IDE 分为 Ultimate（企业版）、Professional（专业版）和 Community（社区免费）这几个版本，其中企业版和专业版是要收费的，相比于社区版功能更多。\n利用 JetBrains 家产品都有免费一个月的试用期，所以安装一个到期重置试用插件即可。\nJetbrains 系列产品重置试用方法\nide-eval-resetter 下载链接\nPS：每年的 10.24 程序员节等某些节日会打折，建议支持正版！如果你有自己的开源项目或者是教育邮箱也可以申请 JetBrains 全系列产品一年的免费期限。\n其他 国内不少开发也分享了 JetBrains 产品的教程，可以结合官网教程学习\nPyCharm 中文指南\n","date":"2021-12-23T00:00:00Z","permalink":"https://aladdinding.cn/post/jetbrains-%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%E5%90%AB%E7%A0%B4%E8%A7%A3/","title":"JetBrains 开发者工具相关资源（含破解）"},{"content":" Hypertext Transfer Protocol Secure (HTTPS) is an extension of the Hypertext Transfer Protocol (HTTP). It is used for secure communication over a computer network, and is widely used on the Internet. In HTTPS, the communication protocol is encrypted using Transport Layer Security (TLS) or, formerly, its predecessor, Secure Sockets Layer (SSL). The protocol is therefore also often referred to as HTTP over TLS, or HTTP over SSL.\nHTTPS (Hypertext Transfer Protocol Secure) 是基于 HTTP 的扩展，用于计算机网络的安全通信，已经在互联网得到广泛应用。在 HTTPS 中，原有的 HTTP 协议会得到 TLS （安全传输层协议） 或其前辈 SSL （安全套接层） 的加密。因此 HTTPS 也常指 HTTP over TLS 或 HTTP over SSL。\n TLS 报文格式 TLS 协议各种通常分为两部分：\n 靠近应用层的握手协议 TLS Handshaking Protocols 靠近 TCP 的记录层协议 TLS Record Protocol  记录层协议（TLS Record Protocol） 记录层协议也可以理解为报文头（TLS Record header），占用 5 个字节\n 第 1 个字节是类型（Record Type Values），目前有 4 种类型 第 2-3 字节是版本（Version Values），目前有 4 种版本 第 4-5 字节是长度（不包含 TLS 报文头本身长度）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  record type (1 byte) / / version (1 byte major, 1 byte minor) / / / / length (2 bytes) / / / +----+----+----+----+----+ | | | | | | | | | | | | TLS Record header +----+----+----+----+----+ Record Type Values dec hex ------------------------------------- CHANGE_CIPHER_SPEC 20 0x14 ALERT 21 0x15 HANDSHAKE 22 0x16 APPLICATION_DATA 23 0x17 Version Values dec hex ------------------------------------- SSL 3.0 3,0 0x0300 TLS 1.0 3,1 0x0301 TLS 1.1 3,2 0x0302 TLS 1.2 3,3 0x0303   握手协议（TLS Handshaking Protocols） TLS 握手协议还能细分为 5 个子协议：\n change_cipher_spec （密码切换协议，在 TLS 1.3 中这个协议已经删除，为了兼容 TLS 老版本，可能还会存在） alert（警告协议，用来表示关闭信息和错误） handshake（握手协议，TLS 协议簇中最最核心的协议） application_data（应用数据协议） heartbeat （心跳协议，这个是 TLS 1.3 新加的，TLS 1.3 之前的版本没有这个协议）  以记录类型为 handshake 举例：\n其中 Handshake 协议中有 10 种握手消息类型（不计算扩展），格式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  | Record Layer | Handshake Layer | | | | ...more messages +----+----+----+----+----+----+----+----+----+------ - - - -+-- | 22 | | | | | | | | | | |0x16| | | | | | | | |message | +----+----+----+----+----+----+----+----+----+------ - - - -+-- / / | \\ \\----\\-----\\ | / / | \\\\ type: 22 / | \\ handshake message length / type / length: arbitrary (up to 16k) Handshake Type Values dec hex ------------------------------------- HELLO_REQUEST 0 0x00 CLIENT_HELLO 1 0x01 SERVER_HELLO 2 0x02 CERTIFICATE 11 0x0b SERVER_KEY_EXCHANGE 12 0x0c CERTIFICATE_REQUEST 13 0x0d SERVER_DONE 14 0x0e CERTIFICATE_VERIFY 15 0x0f CLIENT_KEY_EXCHANGE 16 0x10 FINISHED 20 0x14   TLS/SSL 握手流程  在交换 Hello 信息中，交换随机数，协商出后续使用的加密套件和对应的算法 单向/双向发送证书允许客户端和服务端进行身份认证 Server/Client key Exchange 根据选择的算法交换相应参数，协商出预备主密钥 双端通过预备主密钥、随机数计算出主密钥，用于后续的对称加密数据传输  完整的握手流程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  Client Server ClientHello --------\u0026gt; ServerHello Certificate* ServerKeyExchange* CertificateRequest* \u0026lt;-------- ServerHelloDone Certificate* ClientKeyExchange CertificateVerify* [ChangeCipherSpec] Finished --------\u0026gt; [ChangeCipherSpec] \u0026lt;-------- Finished Application Data \u0026lt;-------\u0026gt; Application Data   *表示着此阶段在某些条件下不存在，[]表示不属于握手报文\nClient Hello(Client -\u0026gt; Server) 主要作用是告诉 Server，Client 所支持的 TLS 协议版本、支持的加密算法等等。\nClient 随机数（Random）：Client 生成的随机数，暂时称作 ClientHello random，用于后续的主密钥生成。\n会话 ID（Session ID）：当 Client 通过一次完整的握手，与 Server 建立了一次完整的 Session，Server 会记录这次 Session 的信息，以备恢复会话的时候使用。上图中该字段为空，说明这是第一次连接到服务器。\n加密算法套件（Cipher Suite）：包含了 Client 所支持的密码算法套件。TLS 中使用的密码套件有一种标准格式。上面的抓包中，Client 发送了 46 套加密套件，Server 会从中选出一种用于本次加密连接使用。一个加密算法套件是 4 个算法的组合。\n压缩方法（Compression Methods）：加密之前的压缩算法。这个字段在 TLS 1.2 中用的不多。在 TLS 1.3 中这个字段被删除。\n扩展（Extension）：结构定义是一个枚举类型，用于携带一些扩展参数，加强 TLS 功能。（携带域名，是否支持 http/2.0 等等）\nServer Hello(Server -\u0026gt; Client) 收到 Client Hello 之后服务器必须发送 Server Hello 信息，Server 会检查 TLS 版本和算法的 Client Hello 的条件，如果服务器接受并支持所有条件，它将发送其证书以及其他详细信息。否则，服务器将发送握手失败消息。\nServer 随机数（Random）：Server 生成的随机数，暂时称作 ServerHello random。注意，至此 Client 和 Server 都拥有了两个随机数。\n会话 ID（Session ID）：服务器将约定的 Session 参数存储在 TLS 缓存中，并生成与其对应的 Session id。它与 Server Hello 一起发送到 Client。Client 可以写入约定的参数到此 Session id，并给定到期时间。Client 将在 Client Hello 中包含此 id。如果 Client 在此到期时间之前再次连接到服务器，则服务器可以检查与 Session id 对应的缓存参数，并重用它们而无需完全握手。这非常有用，因为服务器和 Client 都可以节省大量的计算成本。\n加密算法套件（Cipher Suite）：抓包中 Server 选择了 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)，其中密钥协商算法是 ECDHE、身份认证算法是 RSA、加密模式是 AES_128_GCM、消息认证码算法（MAC）是 SHA256。\n压缩方法（Compression Methods）：如果支持，服务器将同意 Client 的首选压缩方法。\n扩展（Extension）：同上，只有由 Client 给出的扩展才能出现在 Server 的列表中。\nCertificate(Server -\u0026gt; Client) Server 将数字证书和到根 CA 整个链发给 Client，使得 Client 能用证书中公钥进行认证。\nServer Key Exchange(Server -\u0026gt; Client) 主要作用是根据不同的密钥协商算法交换必要的密码信息。\n如果密钥协商算法是 (EC)DHE，所以需要此阶段传递 DH 参数和 DH 公钥。\n如果密钥协商算法为 RSA ，Client 不需要额外参数就可以计算出预备主密钥，然后使用 Server Certificate 中的公钥加密发送给 Server，所以不需要此阶段。\nCertificate Request(Server -\u0026gt; Client, 可选） 这一步是可选的，如果有则表示双向认证。如果在对安全性要求高的常见可能用到。服务器用来验证 Client。服务器端发出 Certificate Request 消息，要求 Client 发他自己的证书过来进行验证。例如银行给你发的 USB 盾牌。\nServer Hello Done(Server -\u0026gt; Client) 此消息完成握手协商的服务器部分，它不携带任何附加信息。\n从 Server Hello 到 Server Hello Done，有些 Server 的实现是每条单独发送，有 Server 实现是合并到一起发送。Sever Hello 和 Server Hello Done 都是只有头没有内容的数据。\nCertificate(Client -\u0026gt; Server, 可选） 如果 Server 要求发送 Client 证书，Client 便会在该阶段将自己的证书发送过去。Server 在之前发送的 Certificate Request 消息中包含了服务器端所支持的证书类型和 CA 列表，因此 Client 会在自己的证书中选择满足这两个条件的第一个证书发送过去。若 Client 没有证书，则发送一个 no_certificate 警告。\nClient Key Exchange(Client -\u0026gt; Server) 主要作用是交换或者协商出预备主密钥，用于主密钥的计算。\n对于 RSA 握手协商算法来说，Client 会生成的一个 48 字节的预备主密钥，其中前 2 个字节是 ProtocolVersion，后 46 字节是随机数，用 Server 的公钥加密之后通过此阶段发给 Server，Server 用私钥来解密。\n对于 (EC)DHE 密钥协商算法来说，预备主密钥是双方通过椭圆曲线算法生成的，双方各自生成临时公私钥对，保留私钥，将公钥发给对方，然后就可以用自己的私钥以及对方的公钥通过椭圆曲线算法来生成预备主密钥。此时传递的是 (EC)DHE 算法公钥（图中的 Pubkey），预备主密钥是密钥在双方不直接传递密钥的情况下得到的。\n当 Server 获得了可以计算预备主密钥的所有条件后，结合之前的 ClientHello random 和 ServerHello random，通过伪随机函数 PRF 生成并截取 48 字节为主密钥，用于后续对称加密传输数据的密钥，Client 同理。\nChange Cipher Spec(Client -\u0026gt; Server) 主要作用是表明接下来传输数据过程中可以对应用数据协议进行加密了。\n密码切换协议，表示随后的信息都将用双方商定的加密方法和密钥发送（Change Cipher Spec 是一个独立的协议，体现在数据包中就是一个字节的数据，用于告知 Server，Client 已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件加密数据并传输了。其中第一条加密的消息就是接下来的 Encrypted Handshake Message\nEncrypted Handshake Message(Client -\u0026gt; Server, 也称 Finshed) 生成对称加密密钥之后，发送一条加密的数据，让 Server 解密验证，确认密钥的正确性。\nChange Cipher Spec(Server -\u0026gt; Client) 密码切换协议，服务端和客户端一样，告诉客户端可以开始加密通信。\nEncrypted Handshake Message(Server -\u0026gt; Client, 也称 Finshed) 生成对称加密密钥之后，发送一条加密的数据，让客户端解密验证；如果对方可以解密，则双方认证无误开始通信。\nAPPLICATION_DATA(CLient \u0026lt;-\u0026gt; Server) 这个阶段就很简单了，数据开始加密传输，其中Record Type Values 为 Application Data（23）\n参考  Traffic analysis of a TLS session The Transport Layer Security (TLS) Protocol Version 1.2 HTTPS 温故知新系列——冰霜大佬  ","date":"2021-11-23T00:00:00Z","permalink":"https://aladdinding.cn/post/https-%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%8F%A1%E6%89%8B%E7%9A%84/","title":"HTTPS 协议是如何握手的"},{"content":"Redis 中字符串的实现并没有完全使用 C 字符串，而是重新定义了简单动态字符串 SDS（Simple Dynamic String）用来表示字符串（Redis 3.2前）。\nsds.h/sdshdr\n1 2 3 4 5  struct sdshdr { unsigned int len; // 记录 buf 数组中已使字节的数量  unsigned int free; // 记录 buf 数组中未使用字节的数量  char buf[]; // 字节数组，用于保存字符串 };   buf 数组长度不一定就是字符串长度 + 1（\u0026quot;\\0\u0026quot;），还有 free 空间，数组内未使用的字节通过 free 属性记录。\n相比于 C 字符串，SDS 有以下优势：\n兼容部分 C 字符串函数 sds.c/sdsnew\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  * mystring = sdsnewlen(\u0026#34;abc\u0026#34;,3); * * You can print the string with printf() as there is an implicit \\0 at the * end of the string. However the string is binary safe and can contain * \\0 characters in the middle, as the length is stored in the sds header. */ sds sdsnewlen(const void *init, size_t initlen) { struct sdshdr *sh; if (init) { sh = zmalloc(sizeof(struct sdshdr)+initlen+1); } else { sh = zcalloc(sizeof(struct sdshdr)+initlen+1); } if (sh == NULL) return NULL; sh-\u0026gt;len = initlen; sh-\u0026gt;free = 0; if (initlen \u0026amp;\u0026amp; init) memcpy(sh-\u0026gt;buf, init, initlen); sh-\u0026gt;buf[initlen] = \u0026#39;\\0\u0026#39;; return (char*)sh-\u0026gt;buf; } /* Create a new sds string starting from a null termined C string. */ sds sdsnew(const char *init) { size_t initlen = (init == NULL) ? 0 : strlen(init); return sdsnewlen(init, initlen);   从 SDS 的创建逻辑中可以看出\n SDS 遵循 C 字符串以空字符（\u0026quot;\\0\u0026quot;）结尾。 SDS 中的 len 属性（sds.h/sdslen）同 C 字符串函数 strlen 返回结果相同，即不计算尾部空字符。  这样 SDS 就可以直接重用一部分 C 字符串函数库里面的函数（如打印，显示类函数，\u0026lt;stdio.h\u0026gt;/printf），而字符串的修改操作，则使用 SDS 自定义优化后的函数。\n常数复杂度获取字符串长度 C 获取一个 C 字符串的长度，程序必须遍历整个字符串，直到遇到代表字符串结尾的空字符串位置，这个操作的复杂度为 O(N)。\n但是对于 SDS 来说，获取字符串长度只需要访问 SDS 中的 len 属性。复杂度仅为 O(1)，确保了获取字符串长度这样的高频操作不会成为 Redis 性能瓶颈。\n对于 SDS 的修改操作，SDS 会实时维护 len 属性，如 sds.c/sdscat（追加 C 字符串到 SDS 字符串）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /* Append the specified binary-safe string pointed by \u0026#39;t\u0026#39; of \u0026#39;len\u0026#39; bytes to the * end of the specified sds string \u0026#39;s\u0026#39;. * * After the call, the passed sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdscatlen(sds s, const void *t, size_t len) { struct sdshdr *sh; size_t curlen = sdslen(s); s = sdsMakeRoomFor(s,len); if (s == NULL) return NULL; sh = (void*) (s-(sizeof(struct sdshdr))); memcpy(s+curlen, t, len); sh-\u0026gt;len = curlen+len; sh-\u0026gt;free = sh-\u0026gt;free-len; s[curlen+len] = \u0026#39;\\0\u0026#39;; return s; } /* Append the specified sds \u0026#39;t\u0026#39; to the existing sds \u0026#39;s\u0026#39;. * * After the call, the modified sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdscatsds(sds s, const sds t) { return sdscatlen(s, t, sdslen(t)); }   杜绝缓冲区溢出 C 字符串由于不记录自身长度，对其进行修改操作容易造成缓冲区溢出（buffer overflow）。如 C 字符串拼接函数 \u0026lt;stdio.h\u0026gt;/strcat，内存中相邻的字符串 s1 和 s2，对 s1 字符串做拼接操作时，如果没有提前为 s1 分配足够的空间，则 s2 保存的内容会被意外修改。\nSDS 内部维护了一个 free 字段，当 SDS API 需要对其进行修改时，API 会调用 sdsMakeRoomForDS 函数检测当前 SDS 的 free 空间是否满足要求，满足直接进行修改；不满足 sdsMakeRoomForDS 则会将 SDS 的空间扩展至执行修改所需的大小，避免缓冲区溢出的情况（如上方 sds.c/sdscat）。\n减少修改字符串长度时所需内存重分配次数 Redis 作为数据库，经常被用于速度要求严苛，数据被频繁修改的场景。SDS 实现了 空间预分配 和 惰性空间释放 两种优化策略。\nsds.c/sdsMakeRoomFor\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  /* Enlarge the free space at the end of the sds string so that the caller * is sure that after calling this function can overwrite up to addlen * bytes after the end of the string, plus one more byte for nul term. * * Note: this does not change the *length* of the sds string as returned * by sdslen(), but only the free buffer space we have. */ sds sdsMakeRoomFor(sds s, size_t addlen) { struct sdshdr *sh, *newsh; size_t free = sdsavail(s); size_t len, newlen; if (free\u0026gt;= addlen) return s; len = sdslen(s); sh = (void*) (s-(sizeof(struct sdshdr))); newlen = (len+addlen); if (newlen \u0026lt; SDS_MAX_PREALLOC) newlen *= 2; else newlen += SDS_MAX_PREALLOC; newsh = zrealloc(sh, sizeof(struct sdshdr)+newlen+1); if (newsh == NULL) return NULL; newsh-\u0026gt;free = newlen - len; return newsh-\u0026gt;buf; }   空间预分配 可以发现，在 SDS API 进行字符串新增逻辑中会给 SDS 重新分配 free 空间。\n 如果 SDS 的长度（len 属性）小于 SDS_MAX_PREALLOC（1024KB=1M），则会分配和 len 属性同样大小的未使用空间给 buf，这时 SDS 的 len 属性和 free 属性值相同。 如果 SDS 长度大于或者等于 SDS_MAX_PREALLOC（1024KB=1M），则会直接给 free 属性分配 SDS_MAX_PREALLOC（1024KB=1M） 的大小。  通过空间预分配策略，Redis 可以减少连续执行字符串增长操作所需的内存重分配次数.\n惰性空间释放 sds.c/sdstrim\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /* Remove the part of the string from left and from right composed just of * contiguous characters found in \u0026#39;cset\u0026#39;, that is a null terminted C string. * * After the call, the modified sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. * * Example: * * s = sdsnew(\u0026#34;AA...AA.a.aa.aHelloWorld :::\u0026#34;); * s = sdstrim(s,\u0026#34;A. :\u0026#34;); * printf(\u0026#34;%s\\n\u0026#34;, s); * * Output will be just \u0026#34;Hello World\u0026#34;. */ sds sdstrim(sds s, const char *cset) { struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr))); char *start, *end, *sp, *ep; size_t len; sp = start = s; ep = end = s+sdslen(s)-1; while(sp \u0026lt;= end \u0026amp;\u0026amp; strchr(cset, *sp)) sp++; while(ep\u0026gt; start \u0026amp;\u0026amp; strchr(cset, *ep)) ep--; len = (sp\u0026gt; ep) ? 0 : ((ep-sp)+1); if (sh-\u0026gt;buf != sp) memmove(sh-\u0026gt;buf, sp, len); sh-\u0026gt;buf[len] = \u0026#39;\\0\u0026#39;; sh-\u0026gt;free = sh-\u0026gt;free+(sh-\u0026gt;len-len); sh-\u0026gt;len = len; return s; }   可以发现，在进行字符串剪切操作时，多出的 buf 空间并不会直接释放，而是存储在 free 字段中。\n同时为了避免内存泄露，SDS 也提供了 sds.c/sdsRemoveFreeSpace 释放 free 空间操作，在 redis.c/clientsCronResizeQueryBuffer 中可以看到，当 querybuf 大于 1024 字节，会进行释放操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  /* Reallocate the sds string so that it has no free space at the end. The * contained string remains not altered, but next concatenation operations * will require a reallocation. * * After the call, the passed sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdsRemoveFreeSpace(sds s) { struct sdshdr *sh; sh = (void*) (s-(sizeof(struct sdshdr))); sh = zrealloc(sh, sizeof(struct sdshdr)+sh-\u0026gt;len+1); sh-\u0026gt;free = 0; return sh-\u0026gt;buf; } /* The client query buffer is an sds.c string that can end with a lot of * free space not used, this function reclaims space if needed. * * The function always returns 0 as it never terminates the client. */ int clientsCronResizeQueryBuffer(redisClient *c) { size_t querybuf_size = sdsAllocSize(c-\u0026gt;querybuf); time_t idletime = server.unixtime - c-\u0026gt;lastinteraction; /* There are two conditions to resize the query buffer: * 1) Query buffer is \u0026gt; BIG_ARG and too big for latest peak. * 2) Client is inactive and the buffer is bigger than 1k. */ if (((querybuf_size\u0026gt; REDIS_MBULK_BIG_ARG) \u0026amp;\u0026amp; (querybuf_size/(c-\u0026gt;querybuf_peak+1)) \u0026gt; 2) || (querybuf_size\u0026gt; 1024 \u0026amp;\u0026amp; idletime \u0026gt; 2)) { /* Only resize the query buffer if it is actually wasting space. */ if (sdsavail(c-\u0026gt;querybuf) \u0026gt; 1024) { c-\u0026gt;querybuf = sdsRemoveFreeSpace(c-\u0026gt;querybuf); } } /* Reset the peak again to capture the peak memory usage in the next * cycle. */ c-\u0026gt;querybuf_peak = 0; return 0; }   二进制安全 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据（如不以 \u0026ldquo;\\0\u0026rdquo; 当作字符串结尾），程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，他被读取时就是什么样子。因此 Redis 可以不仅可以保存文本数据，还可以保存图片、音频、视频、压缩文件这样的二进制数据。\nSDS API ","date":"2021-11-05T00:00:00Z","permalink":"https://aladdinding.cn/post/redis-%E6%BA%90%E7%A0%81%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Redis 源码之简单动态字符串"},{"content":"有关静态博客部署的文章、视频教程已经很多了。\n大致总结可以分为三类：\n Github Pages + Github Action（网站托管，如：Vercel） 本地编译 + rsync 远程服务器 本地编译 + 推送对象存储（七牛云）  最佳实践  本地更新完文章提交推送 触发 Github Action Action 的 workflow 中完成静态资源的编译、推送至云服务器 云服务器 Nginx 访问静态资源   之前博客一直部署在 Github+Vercel，奈何美国服务器延迟太高，\n国内的阿里云、腾讯云的网站托管、云开发体验太差，\n刚好双十一购入三年的 2 核 4G 8M 带宽的轻量服务器（腾讯云 YYDS）！！！\n趁着周末研究研究如何部署到云服务器上，\n总体体验不错，满足了我既要远程编译，Github 托管代码、访问速度要快的需求，\n这套流程中你只需要写好文章（不需要编博客译环境），推送至 Github 即可，\n没有跑完这整个流程之前还比较担心 Github rsync 到腾讯云服务器会不会要很久，毕竟 Github 服务器在美国\n实际测试 30s 内就可以完成整套 workflow，还是比较满意的\nPS：首次可能会慢点，后续的 rsync 应该都是增量更新\n顺带也开启了 HTTP/2.0，还是挺香的\n部分配置文件 使用 PEM 格式生成公钥私钥\n1  ssh-keygen -m PEM -t rsa -b 4096   生成的公钥追加到 authorized_keys 中\n1  cd .ssh/;cat id_rsa.pub \u0026gt;\u0026gt; authorized_keys   .github/workflows/main.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  # This is a basic workflow to help you get started with Actionsname:github pages# Controls when the workflow will runon:# Triggers the workflow on push or pull request events but only for the main branchpush:branches:[main]paths-ignore:- \u0026#39;.gitignore\u0026#39;- \u0026#39;README.md\u0026#39;pull_request:branches:[main]# Allows you to run this workflow manually from the Actions tabworkflow_dispatch:# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs:# This workflow contains a single job called \u0026#34;build\u0026#34;deploy:# The type of runner that the job will run onruns-on:ubuntu-latestconcurrency:group:${{github.workflow}}-${{ github.ref }}# Steps represent a sequence of tasks that will be executed as part of the jobsteps:# Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it- uses:actions/checkout@v2# Runs a single command using the runners shell- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:\u0026#39;0.85.0\u0026#39;extended:true- name:Buildrun:hugo --minify# Runs a set of commands using the runners shell- name:Github Deployuses:peaceiris/actions-gh-pages@v3if:github.ref == \u0026#39;refs/heads/main\u0026#39;with:github_token:${{secrets.ACCESS_TOKEN}}publish_dir:./public# Deploy to Server- name:Serveruses:easingthemes/ssh-deploy@mainenv:SSH_PRIVATE_KEY:${{secrets.SERVER_SSH_KEY}}SOURCE:\u0026#34;public/\u0026#34;REMOTE_HOST:${{secrets.REMOTE_HOST}}REMOTE_USER:${{secrets.REMOTE_USER}}TARGET:${{secrets.REMOTE_TARGET}}  Nginx 配置文件  开启了 HTTP/2.0 HTTP 访问 301 跳转到 HTTPS  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  server { listen 80; listen [::]:80; server_name \u0026lt;your.domain\u0026gt;; return 301 https://$host$request_uri; } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name \u0026lt;your.domain\u0026gt;; ssl_certificate \u0026#34;\u0026lt;your.pem\u0026gt;\u0026#34;; ssl_certificate_key \u0026#34;\u0026lt;your.key\u0026gt;\u0026#34;; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; location / { root \u0026lt;your.dir\u0026gt;/public; index index.html; } }   ","date":"2021-11-04T00:00:00Z","permalink":"https://aladdinding.cn/post/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E9%80%82%E7%94%A8-hugohexo/","title":"静态博客部署的最佳实践（适用 Hugo、Hexo）"},{"content":"go build 使用：\n1  go build [-o 输出名] [-i] [编译标记] [包名]   默认我们 go build 的可执行文件都是当前操作系统可执行的文件，如果我想在 macOS 下编译一个 linux 下可执行文件，那需要怎么做呢？\n只需要指定目标操作系统的平台和处理器架构即可，例如 Window 平台终端下按如下方式指定环境变量。\n1 2 3  SET CGO_ENABLED=0 // 禁用 CGO SET GOOS=linux // 目标平台是 linux SET GOARCH=amd64 // 目标处理器架构是 amd64   macOS 编译 Linux 和 Windows 平台 64 位 可执行程序:\n1 2  CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build   Linux 编译 Mac 和 Windows 平台 64 位可执行程序：\n1 2  CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build   Windows 编译 Mac 平台 64 位可执行程序\n1 2 3 4  SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build   ","date":"2021-10-29T00:00:00Z","permalink":"https://aladdinding.cn/post/go-%E8%AF%AD%E8%A8%80%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/","title":"Go 语言跨平台编译"},{"content":"处理排骨  排骨冷水下锅，放入生姜、葱段、料酒去腥 水开后撇去浮沫 倒出排骨，冷水冲洗，沥干水分  煎制排骨  热锅凉油放入生姜葱段爆香 倒入沥干水分的排骨煎制两面金黄 淋入料酒去腥 倒入开水淹没过排骨  砂锅炖汤  水沸后转入砂锅 加入姜片、花椒、葱结、料酒去腥 大火炖煮至沸腾 加入配菜，如：玉米、山药、胡萝卜等 转小火继续炖煮 1 小时左右（切记不要炖久了，肉会烂成肉渣）  中途不要放盐，吃的时候在放盐\n","date":"2021-09-13T00:00:00Z","permalink":"https://aladdinding.cn/post/%E7%82%96%E6%8E%92%E9%AA%A8%E6%B1%A4%E7%9A%84%E6%8A%80%E5%B7%A7/","title":"炖排骨汤的技巧"},{"content":" 本书主要介绍了计算机系统的基本概念, 包括最底层的内存中的数据表示、流水线指令的构成、虚拟存储器、编译系统、动态加载库以及用户应用等。书中提供了大量实际操作, 可以帮助读者更好地理解程序执行的方式, 改进程序的执行效率。\n 一本相见恨晚的书，非计科出身果然还是有很长的路要走。\n首次阅读确实不是很懂，可以暂时放一放\n当有了实际编码经验、抽象思维逻辑再阅读，你会有所收获的！\n教材 1 2 3  我用阿里云盘分享了「深入理解计算机系统（第三版）.pdf」，你可以不限速下载🚀 复制这段内容打开「阿里云盘」App 即可获取 链接：https://www.aliyundrive.com/s/bTBiCehPPJv   视频 \r\r\r#biliplayer {\rwidth: 100%;\rheight: 550px;\r}\r@media only screen and (min-device-width: 320px) and (max-device-width: 480px) {\r#biliplayer {\rwidth: 100%;\rheight: 250px;\r}\r}\r 其他 https://github.com/EugeneLiu/translationCSAPP\nhttps://www.zhihu.com/question/20354069\n","date":"2021-08-21T00:00:00Z","permalink":"https://aladdinding.cn/post/%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/","title":"学习《深入理解计算机系统》"},{"content":"忽略 macOS Catalina 10.15 更新通知 隐藏 / 关闭更新通知依次打开 启动台 - 其他 - 终端，输入以下神秘代码，Enter 后输入用户密码即可。\n1  sudo softwareupdate --ignore \u0026#34;macOS Catalina\u0026#34;   将来要是想开了，又想更新了，再次输入以下神秘代码即可。\n1  sudo softwareupdate --reset-ignored   Tip：此方法在 macOS 10.16 Big Sur 已经不适用，暂时没有找到合适的方法\n屏蔽升级 Catalina 软件更新小红点 如果在此之前已经点击了软件更新出现了小红点，对于强迫症用户十分不友好。\n打开 启动台 - 其他 - 终端 - 输入\n1  defaults write com.apple.systempreferences AttentionPrefBundleIDs 0   然后继续输入\n1  killall Dock   烦人的小红点就消失了！！！\n外接显示器 Dock 栏会乱跑 鼠标在上方屏幕红框处，也就是鼠标移不下去的地方放置一两秒，Dock 栏就会跑到上方屏幕\n同理，鼠标放下下方屏幕，鼠标移不下去的地方放置，Dock 栏就会跑到下方屏幕\n个人感觉这个设计很烂，而且也没有开关能永久固定 Dock 栏，希望 Appple 设计师能改改！！！\n也可以在设置 -\u0026gt; 调度中心取消勾选「显示器具有单独的空间」\n按住 Command 连续选中文件 Command 键是 macOS 上最基础的文件选择辅助按键之一。按住 Command 后再选文件，只要保持 Command 键一直按着，已经选中的文件就会一直保持被选中的状态。 相关的快捷键有：Command+A 全选所有文件\n按住 Command 连续选中文件 Command 键是 macOS 上最基础的文件选择辅助按键之一。按住 Command 后再选文件，只要保持 Command 键一直按着，已经选中的文件就会一直保持被选中的状态。 相关的快捷键有：Command+A 全选所有文件\n按住 Command + 鼠标移动，可以快速移动和删除图标 这个组合键，适用于 Mac 菜单栏上的图标和一些包括 Finder 在内的系统自带软件的菜单栏。\n通过 Command + 点击在新窗口中打开 Finder 侧边栏上的项目 点住 Command 键后，再点击 Finder 侧边栏上的任意项目，这样就可以在新 Finder 窗口中打开。这个操作可以应用在任何侧边栏项目，包括收藏、共享和设备。当我们想要在两个窗口之间复制或移动文件时，这个功能非常实用。\nCommand + 鼠标拖拽可以移动后方的窗口，同时不影响前端窗口 想要查看背景中窗口，但是不想失去对最前方窗口的控制？通过 Command + 拖拽即可实现。\nCommand + 回车 Spotlight 中的搜索结果可以直接在 Finder 中查看 与 Dock 操作一样，当使用 Spotlight 搜索时，只需通过 Command + 回车即可打开搜索结果中文件的位置，直接回车会打开文件。\n使用 Command 键选择不相邻的文件 Command 的其他组合键   Command + W：关闭最前面的窗口\n  Command + M：将最前面的窗口最小化至 “程序坞”\n  Command + F：查找\n  Command + X：剪切所选项并拷贝到剪贴板\n  Command + C：将所选项拷贝到剪贴板\n  Command + V：将剪贴板的内容粘贴到当前文稿或应用中\n  Command + Z：撤销上一个命令\n  Command + A：全选各项\n  Command + tab：切换应用\n  Command + shift + 3: 全屏截图\n  Command + shift + 4: 部分截图\n  ","date":"2021-07-30T00:00:00Z","permalink":"https://aladdinding.cn/post/macos-%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/","title":"MacOS 使用小方法总结"},{"content":"Confluence  Confluence 是一个专业的企业知识管理与协同软件，也可以用于构建企业 wiki。使用简单，但它强大的编辑和站点管理特征能够帮助团队成员之间共享信息、文档协作、集体讨论，信息推送\n 数据库设置 不建议将数据库部署在 Docker 容器，推荐使用云数据库或者物理机数据库。\n文档 Confluence Data Center and Server documentation\nDatabase Configuration\n数据库设置 选择安装的 Confluence 版本，阅读 Database Setup For MySQL 后，修改Mysql 配置文件，本文以 Mysql 8.0 为例\n1 2 3 4 5 6 7 8 9 10 11 12 13  [mysqld] ... character-set-server=utf8mb4 collation-server=utf8mb4_bin default-storage-engine=INNODB max_allowed_packet=256M innodb_log_file_size=2GB transaction-isolation=READ-COMMITTED binlog_format=row log-bin-trust-function-creators = 1 // 如果为 Mysql5.7，关闭 derived_merge 能优化仪表板加载缓慢 optimizer_switch = derived_merge=off ...   如果 sql_mode = NO_AUTO_VALUE_ON_ZERO，请删除此选项\n创建数据库 \u0026amp; 用户  创建数据库  1  CREATEDATABASE\u0026lt;database-name\u0026gt;CHARACTERSETutf8mb4COLLATEutf8mb4_bin;   创建用户  1  CREATEuser\u0026#39;\u0026lt;confluenceuser\u0026gt;\u0026#39;@\u0026#39;localhost\u0026#39;IDENTIFIEDBY\u0026#39;\u0026lt;password\u0026gt;\u0026#39;;  如果 Confluence 与数据库不在同一台服务器上运行（或者是 Docker 用户），请用 Confluence 服务器的主机名或 IP 地址替换 localhost（也可以使用 %，表示允许所有 host）\n 授权  1  GRANTALLPRIVILEGESON\u0026lt;database-name\u0026gt;.*TO\u0026#39;\u0026lt;confluenceuser\u0026gt;\u0026#39;@\u0026#39;localhost\u0026#39;WITHGRANTOPTION;  Docker Compose 文档 镜像：atlassian/confluence-server\n破解插件：atlassian-agent 项目已被私有，无法访问\n准备工具 破解插件 atlassian-agent.jar 直接使用仓库内 atlassian-agent.jar\n数据库驱动 官方镜像并没有内置 MySQL driver，需要自行下载：Database JDBC Drivers。\nMysql 8.0 下载：mysql-connector-java-8.0.22.jar\nMysql 5.7 下载：mysql-connector-java-5.1.48.jar\ndocker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  version:\u0026#39;3\u0026#39;services:confluence:image:\u0026#34;atlassian/confluence-server\u0026#34;volumes:- ./atlassian-agent.jar:/var/atlassian/atlassian-agent.jar- ./mysql-connector-java-8.0.22.jar:/opt/atlassian/confluence/confluence/WEB-INF/lib/mysql-connector-java-8.0.22.jar- ~/your-confluence-home:/var/atlassian/application-data/confluenceenvironment:- JAVA_OPTS=\u0026#34;-javaagent:/var/atlassian/atlassian-agent.jar\u0026#34;- JVM_MINIMUM_MEMORY=2048m- JVM_MAXIMUM_MEMORY=2048m- JVM_RESERVED_CODE_CACHE_SIZE=512mports:- \u0026#34;8090:8090\u0026#34;restart:always  默认内存分配为 1024m，如果需要覆盖 Confluence Server 的默认内存分配，可以通过环境变量 JVM_MINIMUM_MEMORY、JVM_MAXIMUM_MEMORY、JVM_RESERVED_CODE_CACHE_SIZE 控制最小堆 (Xms) 和最大堆(Xmx)。\n1 2  # 重新创建容器实现修改 docker-compose up --force-recreate -d   运行 1  docker-compose up -d   查看日志，发现 ========= agent working ========= 则插件正常运行\n初始化配置 破解 复制 Server ID BT5W-KP7Q-31DT-PTNG，使用容器内的 Java 环境，进入存放 atlassian-agent.jar 目录，运行下方命令生成 Key\n1  java -jar atlassian-agent.jar -d -m test@test.com -n BAT -p \u0026#39;conf\u0026#39; -o http://localhost:8090 -s BT5W-KP7Q-31DT-PTNG   设置数据库 这里使用的宿主机搭建的 Mysql 8.0，一路下一步即可\n查看授权细节 插件破解 第三方插件将其应用密钥 / 插件关键字作为 - p 参数。如：-p \u0026lsquo;com.valiantys.spreadsheets\u0026rsquo;\n1  java -jar atlassian-agent.jar -d -m mytest@mytest.com -n BAT -p \u0026#39;com.valiantys.spreadsheets\u0026#39; -o http://localhost:8090 -s BDMK-KXF1-H7GV-F7QG   查找新应用，选择你想要的应用插件，点击免费使用，点击接受 \u0026amp; 安装，进入管理应用页面，粘贴生成的许可证，点击更新完成破解\nJIRA  JIRA 是 Atlassian 公司出品的项目与事务跟踪工具，被广泛应用于缺陷跟踪、客户服务、需求收集、流程审批、任务跟踪、项目跟踪和敏捷管理等工作领域。\n Jira 搭建流程和 Confluence 类似，这里不再赘述，附上相关内容\n文档 Jira Software Data Center and Server documentation\nConnecting Jira applications to a database\n镜像：atlassian/jira-software\n破解命令 1  java -jar atlassian-agent.jar -d -m test@test.com -n BAT -p \u0026#39;jira\u0026#39; -o http://localhost:8080 -s BT5W-KP7Q-31DT-PTNG   配置 Confluence 与 Jira 用户数据对接 进入 Jira 选择用户管理 \u0026gt; Jira 用户服务器 \u0026gt; 添加应用程序\n进入 Confluence \u0026gt; 用户管理 \u0026gt; 用户目录 \u0026gt; 添加目录（目录类型为：Atlassian Jira）\n将 JIRA Server 顺序顶置最上，点击同步即可将 Jira 用户信息同步到 Confluence\n如果是通过备份还原的 Jira 及 Confluence 可以直接禁用之前的用户目录然后移除。其他应用程序关联等设置比较简单，自行操作。\n异常记录 Confluence 重启后一段时间内无响应 1 2 3 4 5 6  confluence_1 | WARNING: An illegal reflective access operation has occurred confluence_1 | WARNING: Illegal reflective access by com.atlassian.hibernate.adapter.proxy.BytecodeProviderImpl_ImplementV2Proxy (file:/opt/atlassian/confluence/confluence/WEB-INF/lib/hibernate.adapter-1.0.3.jar) to field java.lang.reflect.Field.modifiers confluence_1 | WARNING: Please consider reporting this to the maintainers of com.atlassian.hibernate.adapter.proxy.BytecodeProviderImpl_ImplementV2Proxy confluence_1 | WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations confluence_1 | WARNING: All illegal access operations will be denied in a future release confluence_1 | Security framework of XStream not explicitly initialized, using predefined black list on your own risk.   类似问题：\nhttps://community.atlassian.com/t5/Confluence-questions/Confluence-no-longer-responds-Debugging-articles/qaq-p/1404597\nhttps://community.atlassian.com/t5/Confluence-questions/Illegal-reflective-access-by-BytecodeProviderImpl/qaq-p/1255035\nhttps://community.atlassian.com/t5/Confluence-questions/hibernate-adapter-1-0-3-jar/qaq-p/1281057\n不过等待一段时间会自动运行正常。。。\n备份文件恢复失败 Unable to complete import: An invalid XML character (Unicode: 0x8) was found in the CDATA section.\n解压备份文件，下方文档链接中的中的Jar包处理一下 entities.xml 文件，重新打包\nhttps://confluence.atlassian.com/jira/removing-invalid-characters-from-xml-backups-12079.html\n","date":"2021-07-25T00:00:00Z","permalink":"https://aladdinding.cn/post/docker-%E9%83%A8%E7%BD%B2%E5%B9%B6%E7%A0%B4%E8%A7%A3-confluencejira-%E5%8F%8A%E6%8F%92%E4%BB%B6/","title":"Docker 部署并破解 Confluence、JIRA 及插件"},{"content":"时间复杂度 算法的执行时间与算法输入值之间的的关系，即算法的执行效率\n大 O 表示法  用常数 1 取代运行时间中的所有加法常数。 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶  常见时间复杂度 O(1) 常数阶 1 2 3 4  def O1(num): i = num j = num*2 return i + j   O(logn) 对数阶 1 2 3 4 5  def OlogN(num): i = 1 while (i \u0026lt; num): i = i * 2 return i   O(n) 线性阶 1 2 3 4 5  def ON(num): total = 0 for i in range(num): total += i return total   O(nlogn) nlogn 阶 1 2 3 4 5 6 7 8  def ONlogN(num): total = 0 for i in range(num): j = 1 while (j \u0026lt; num): total += i+j j = j * 2 return total   O(n^2) 平方阶 1 2 3 4 5 6  def ON2(num): total = 0 for i in range(num): for j in range(num): total += i+j return total   对比 常用时间复杂度所耗费的时间从小到大依次是：\nO(1) \u0026lt; O(logn) \u0026lt; O(n) \u0026lt; O(nlogn) \u0026lt; O(n^2) \u0026lt; O(n^3) \u0026lt; O(n!) \u0026lt; O(n^n)\n相关文档：Big-O Cheat Sheet\n空间复杂度 算法的存储空间与输入值之间的关系，表示方法同样也为大 O 表示法\n常见时间复杂度 O(1) 常数阶 1 2 3 4 5  def O1(num): total = 0 for i in range(num): total += i return total   O(n) 线性阶 1 2 3 4 5  def ON(nums) array = [] for num in nums: array.append(num) return array   如何计算  变量：常量时为 O(1），数组、列表则可能是 O(n)、O(n^2) 递归：递归栈 O(n)  最坏情况与平均情况 最坏情况运行时间是一种保证，那就是运行时间不会再长了。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。一般没有特殊说明的情况下，时间复杂度都是指最坏时间复杂度。\n如何衡量时间 / 空间复杂度  时间和空间复杂度只能二选一 牺牲时间换空间 牺牲空间换时间 通常是优先选择时间复杂度更好的  ","date":"2021-07-24T00:00:00Z","permalink":"https://aladdinding.cn/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","title":"数据结构与算法之时间、空间复杂度"},{"content":"安装 iTerm2 使用 iTerm2 替代 macOS 自带终端 Terminal\nHome\u0026amp;Download：https://iterm2.com/\n安装 iTerm2 主题 This is a set of color schemes for iTerm (aka iTerm2).\nGithub：https://github.com/mbadolato/iTerm2-Color-Schemes\nExample:\n Dracula iterm2-material-design  安装 oh-my-zsh Oh My Zsh is a delightful, open source, community-driven framework for managing your Zsh configuration.\nHome：https://ohmyz.sh/\nGithub：https://github.com/ohmyzsh/ohmyzsh\n1 2  # Install oh-my-zsh $ sh -c \u0026#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34;   安装 zplug 插件管理器 Github：https://github.com/zplug/zplug\n1  $ curl -sL --proto-redir -all,https https://raw.githubusercontent.com/zplug/installer/master/installer.zsh | zsh   安装命令行工具 fzf 命令行模糊搜索\nGithub：https://github.com/junegunn/fzf\n1 2 3  brew install fzf # To install useful key bindings and fuzzy completion: $(brew --prefix)/opt/fzf/install   NOTE：put this line in the end of your zshrc, or it may not work, https://github.com/junegunn/fzf/issues/1304\n1  [ -f ~/.fzf.zsh ] \u0026amp;\u0026amp; source ~/.fzf.zsh   新增 zpug 插件配置 添加到 ~/.zshrc 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  # install zplug, plugin manager for zsh, https://github.com/zplug/zplug # curl -sL --proto-redir -all,https https://raw.githubusercontent.com/zplug/installer/master/installer.zsh | zsh # zplug configruation if [[ ! -d \u0026#34;${ZPLUG_HOME}\u0026#34; ]]; then if [[ ! -d ~/.zplug ]]; then git clone https://github.com/zplug/zplug ~/.zplug # If we can\u0026#39;t get zplug, it\u0026#39;ll be a very sobering shell experience. To at # least complete the sourcing of this file, we\u0026#39;ll define an always-false # returning zplug function. if [[ $? != 0 ]]; then function zplug() { return 1 } fi fi export ZPLUG_HOME=~/.zplug fi if [[ -d \u0026#34;${ZPLUG_HOME}\u0026#34; ]]; then source \u0026#34;${ZPLUG_HOME}/init.zsh\u0026#34; fi zplug \u0026#39;plugins/git\u0026#39;, from:oh-my-zsh, if:\u0026#39;which git\u0026#39; zplug \u0026#39;romkatv/powerlevel10k\u0026#39;, use:powerlevel10k.zsh-theme zplug \u0026#34;plugins/vi-mode\u0026#34;, from:oh-my-zsh zplug \u0026#39;zsh-users/zsh-autosuggestions\u0026#39; zplug \u0026#39;zsh-users/zsh-completions\u0026#39;, defer:2 zplug \u0026#39;zsh-users/zsh-history-substring-search\u0026#39; zplug \u0026#39;zsh-users/zsh-syntax-highlighting\u0026#39;, defer:2 if ! zplug check; then zplug install fi zplug load   关于字体 在配置 powerlevel10k 主题时若缺少字体会提示下载，当然你也可以自行安装\n Best option if on macOS and want to use Homebrew.\n All fonts are available via Homebrew Cask Fonts on macOS (OS X)\n1 2  brew tap homebrew/cask-fonts brew install --cask font-hack-nerd-font   iTerm2 -\u0026gt; Preferences -\u0026gt; Profiles -\u0026gt; Text -\u0026gt; Non-Ascii-Font -\u0026gt; nerd-font -\u0026gt; restart iTerm2\n","date":"2021-06-04T00:00:00Z","permalink":"https://aladdinding.cn/post/macos-%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/","title":"MacOS 终端配置记录"},{"content":"说到 HTTPS 协议，很多人想到的是配置各种复杂的证书。其实不然，可以说大多数代理能够支持 https 都是通过 http 协议中的 Web 隧道（也有叫做 HTTP 隧道）功能来实现的。\nWeb 隧道 Web 隧道允许用户通过 HTTP 连接发送非 HTTP 流量（例如 FTP，Telnet，SMTP），这样就可以在 HTTP 上携带其他协议数据了。使用 Web 隧道最常见的原因就是要在 HTTP 链接中嵌入非 HTTP 流量。我们知道很多软件都是实现了自己的应用层协议，但是这些软件都支持设置代理，如 QQ，微信。\nWeb 隧道是用 HTTP 的 CONNECT 方法建立起来的。CONNECT 方法并不是 HTTP/1.1 核心规范的一部分，但却是一种得到广泛应用的扩展。CONNECT 方法请求隧道网关创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。下面截取《HTTP 权威指南》配图，讲讲 CONNECT 方法如何建立一条 Web 隧道。\n 客户端首先发送了一条 CONNECT 请求给代理服务器。 代理服务器收到了 CONNECT 请求，解析出报文中客户端希望访问的域名及端口号，然后向目标服务器进行 TCP 连接。（图中是到打开到主机 orders.joes-hardware.com 的标准 SSL 端口 443 的连接） 代理服务器一旦和目标网站建立了 TCP 连接，就发送一条 HTTP 200 Connection Established 的响应来通知客户端 Web 隧道建立成功，可以发送数据了。 此时客户端通过 Web 隧道发送的所有数据都会被代理服务器直接转发给目标网站。（如果是 HTTPS 协议则是各种 SSL 握手信息，加密后的 HTTP 报文）  客户端只有收到 200 Connection Established 才会继续发送数据。如果代理服务器和目标网站连接不成功怎么办呢？代理服务器可以自己灵活自定义：连接目标网站失败 502 Bad Gateway、代理认证未通过 407 Proxy Authentication Required 等等。\nCONNECT 请求 除了起始行之外，CONNECT 的语法与其他 HTTP 方法类似，只不过是主机名和端口号取代了 URI。其中主机和端口都必须指定，不然代理服务器就不清楚与谁建立连接了。\n1 2  CONNECT home.netscape.com:443 HTTP/1.0 User-Agent: Mozilla/4.0   CONNECT 请求的 header 通常只会携带建立 Web 隧道所需要的信息，而不包含需要传输的请求信息。\n常见的 CONNECT 请求 header：\n User-Agent：用户设备 Proxy-Authorization：认证信息 Proxy-Connection：是否支持长连接  CONNECT 响应 发送了请求之后，客户端会等待来自网关的响应。和普通 HTTP 报文一样，响应码 200 表示成功。按照惯例，响应中的原因短语通常被设置为 “Connection Established”。\n1 2  HTTP/1.0 200 Connection Established Proxy-Agent: Netscape-Proxy/1.1   与普通 HTTP 响应不同，这个响应并不需要包含 Content-Type 首部。此时连接只是对原始字节进行转接，不再是报文的承载者，所以不需要使用内容类型了。\n不止 HTTPS 正因为有了 Web 隧道，代理服务器不需要其他应用层协议进行额外的编码解析，只要 Web 隧道建立成功之后即可发送任何非 HTTP 流量。\nwebsocket 在 Python 的 websocket-client 框架中，如果使用 http 代理，首先会对代理发送 CONNECT 连接建立 Web 隧道，然后在传输 ws、wss 协议数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  def _tunnel(sock, host, port, auth): debug(\u0026#34;Connecting proxy...\u0026#34;) connect_header = \u0026#34;CONNECT %s:%dHTTP/1.1\\r\\n\u0026#34; % (host, port) connect_header += \u0026#34;Host: %s:%d\\r\\n\u0026#34; % (host, port) # TODO: support digest auth. if auth and auth[0]: auth_str = auth[0] if auth[1]: auth_str += \u0026#34;:\u0026#34; + auth[1] encoded_str = base64encode(auth_str.encode()).strip().decode().replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;) connect_header += \u0026#34;Proxy-Authorization: Basic %s\\r\\n\u0026#34; % encoded_str connect_header += \u0026#34;\\r\\n\u0026#34; dump(\u0026#34;request header\u0026#34;, connect_header) send(sock, connect_header) try: status, resp_headers, status_message = read_headers(sock) except Exception as e: raise WebSocketProxyException(str(e)) if status != 200: raise WebSocketProxyException( \u0026#34;failed CONNECT via proxy status: %r\u0026#34; % status) return sock   非 Web 隧道 当然，也有的代理服务器能够在不建立 Web 隧道的情况下，实现了对其他应用层协议的解析，从而实现代理转发的目的。\n例如 HTTPS 协议，客户端首先和代理服务器进行代理服务器完成 SSL 握手，代理服务器获取到客户端发送的完整请求（明文），然后在和目标主机进行 SSL 握手，成功后转发用户的请求。最后还要确定使用的 HTTP 客户端是否支持连接 HTTPS 代理，因为绝大多数应用层协议客户端都是通过 Web 隧道使用代理。\n在 Python 的 HTTP 客户端框架 urllib3 的 1.26.0 版本 中才添加了对 HTPPS 代理连接的支持。\n Added support for HTTPS proxies contacting HTTPS servers (Pull #1923, Pull #1806)  1 2 3 4 5  proxies = { \u0026#39;http\u0026#39;: \u0026#39;http://proxy_ip:port\u0026#39;, # http 请求 \u0026#39;https\u0026#39;: \u0026#39;http://proxy_ip:port\u0026#39;, # CONNECT 请求 \u0026#39;https\u0026#39;: \u0026#39;https://proxy_ip:port\u0026#39; # 与 proxy 进行 ssl }   ","date":"2021-05-10T00:00:00Z","permalink":"https://aladdinding.cn/post/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81-https/","title":"代理服务器如何支持 HTTPS"},{"content":"  Now we have become very big, Different from the original idea. Collect premium software in various categories.\nawesome-mac\n 官方 macOS 最新系统：https://www.apple.com.cn/macos\nmacOS 支持：https://support.apple.com/zh-cn/macos\n制作 macOS 安装器：https://support.apple.com/zh-cn/HT201372\nmacOS 使用手册：https://support.apple.com/zh-cn/guide/mac-help/welcome/mac\n序列号查询：https://checkcoverage.apple.com/cn/zh/\n软件下载 MacWk：https://macwk.com/\n马可菠萝：https://www.macbl.com/\n瓜子云盘：https://yun.naodai.org/Software\nappstorrent：https://www.appstorrent.ru/\nXclient：https://xclient.info/\n麦氪搜：https://www.imacso.com/\nGithub：https://github.com/search?q=macos\n兼容检测 Arm 芯片兼容：https://isapplesiliconready.com/zh\n","date":"2021-03-20T00:00:00Z","permalink":"https://aladdinding.cn/post/macos-%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90%E5%90%88%E9%9B%86/","title":"MacOS 相关资源合集"},{"content":"墙的原理 在讨论 vpn、proxy 这些之前，有必要先提一下目前主流防火墙的实现原理。GFW 实现网络封锁的手段主要有两种：dns 劫持和 ip 封锁（除此之外，还有 dns 污染和关键词过滤，这里我们不讨论）。\nDns 劫持 ip 是网络上各主机的 “地址”，要想访问 “别人家”，当然得要有地址。但 ip 是一串数字，是给电脑看的，人记起来太麻烦，所以就有了域名（也就是我们常说的网址）和 dns（网域名称系统，Domain Name System）。\n域名是一串英文字符串，方便人记忆。dns 将域名和 ip 关联起来，形成映射。用户访问域名所在的目标网站前，将域名发给 dns 服务器询问这对映射关系，拿到对应的 ip 后就可以在茫茫网海中找到那个 “她” 了。而 GFW 所做的就是站在用户和 dns 服务器之间，破坏它们的正常通讯，并向用户回传一个假 ip。用户拿不到真正的 ip，自然也就访问不到本想访问的网站了。\nDns 劫持是 GFW 早期唯一的技术手段，所以那个时候的用户通过修改 Hosts 文件的方式就可以零成本突破封锁了。\nIP 封锁 dns 劫持之后，GFW 引入了 ip 封锁，直接锁住了访问目标网站的去路，用户发往被封锁 ip 的任何数据都会被墙截断。\n这个时候，依靠类似于修改 Hosts 文件这种低成本方法突破封锁就显得有些天方夜谭了。那么，解决办法是什么呢？答案是：在第三方架设翻墙服务器，中转与目标服务器间的来往流量。目前为止，GFW 采用的是黑名单模式，像 Google、Facebook 这种在黑名单上的网站的 ip 无法访问，而不在黑名单上的第三方不记名 ip 可以。\n于是，一切就很明朗了，我们目前几乎所有的翻墙手段都是基于上述原理实现的。vpn 是，shadowsocks 是，还有一些比较冷门的（比如 v2ray）同样如此，只不过它们的技术细节不同（这个我们不会深入）。\nVPN VPN，全称 “虚拟私人网络（Virtual Private Network）” 或者是“虚拟专用网络”，是一种加密通讯技术。vpn 是一个统称，它有很多的具体实现，比如 PPTP、L2TP/IPSec 等。\nvpn 最常用的场景就是在外网的小伙伴（如酒店网络，家庭 WIFI 等等）访问公司内部的网络使用，如果不使用 vpn，直接连入公司内网，则数据明文在外网中传输会有被窃听的风险。vpn 是一种加密通讯技术，它被设计出来的目的是数据传输安全和网络匿名。\nvpn 出现远早于 GFW，所以它不是为了翻墙而生的。而既然不是为翻墙而生，那从翻墙的角度上讲，vpn 协议就存在诸多问题。使用 VPN，不足之处在于数据分流不灵活，会将开启了 VPN 的设备的所有数据流量全部导向至 VPN 服务器上；另外如果 VPN 服务器上有流量监视软件运行，那么用户所传输的数据将有信息安全威胁；进一步来说，由于 VPN 设计的初衷并不是用于翻墙，因此数据流量的特征非常明显，容易引起审查机构注意，导致被封。\n所以，VPN 这种翻墙方式基本已经没落了。但即便如此，vpn 作为过去很长一段时间最主流最热门最常用最为人所知的翻墙手段，已然成为翻墙的代名词。即便是 vpn 已不再常用的今天，当人们谈及翻墙的时候，说得最多的仍是：“你有什么好用的 vpn 吗？”。\nProxy（代理） Proxy（代理）又分为正向代理和反向代理。\n正向代理 翻墙所用的代理都是正向代理。正向代理主要有 HTTP、HTTP over TLS(HTTPS)、Socks、Socks over TLS 几种。其中，HTTP 和 Socks 无法用于翻墙，HTTPS 和 Socks over TLS 可以用于翻墙。不过，Socks over TLS 几乎没人用，我们这里就不多说了。\nProxy 的历史同样早于 GFW，它最早被设计出来的目的当然也不是翻墙。正向代理最主要的目的和 vpn 差不多，都是用于匿名，但 HTTP 和 Socks 不能加密，只能匿名，HTTPS 既可以匿名，也可以用于加密通信。\n从理论上讲，四种代理协议都可以通过 “用户先将数据发给代理服务器，再由代理服务器转发给目的服务器” 的方法达到翻墙目的。但由于 HTTP 和 Socks 都是明文协议，GFW 可以通过检查数据包内的内容得知用户的真实意图，进而拦截数据包。所以，HTTP 和 Socks 一般只用作本地代理。而 HTTPS 协议是加密通讯，GFW 无法得知数据包内的真实内容，类似于关键词过滤的手段无法施展。不仅如此，HTTPS 代理的流量特征和我们平时访问网站时所产生的 HTTPS 流量几乎一模一样，GFW 无法分辨，稳定性爆表。理论上讲，HTTPS 代理无论是安全性，还是在隐匿性，都要比目前最为流行的 shadowsocks 好。\n事实上，在所有已知的翻墙协议中，无论是 vpn 协议，还是代理协议，它应该都是最好的。v2ray 的 vmess over tls 也许能和 HTTPS 代理媲美。但 v2ray 存在的时间较短、使用者较少、社区也没有 HTTPS 代理活跃（从全球范围上看），故而，相比于 HTTPS 代理，vmess 协议潜在的安全漏洞可能要多。\n当然，HTTPS 代理也有它的缺点，其中最大的缺点就是配置复杂。即便能用默认参数就用默认参数，用户自己只作最低限度的配置，对新手而言，这也是一个无比痛苦的过程。更别说，想要正常使用 HTTPS 代理，你还要购买域名和证书这些，非常麻烦。所以，即便是在 shadowsocks 出现之前，HTTPS 代理也没在大陆流行起来。这也是造成 v2ray 的小众的主要原因之一（另一个是用户没有从 shadowsocks 迁移到 v2ray 的动力），它的配置同样相当复杂。除此之外，HTTPS 代理只能转发 tcp 流量，对 udp 无能为力。 这里推荐刘亚晨先生的一篇文章「各种加密代理协议的简单对比」。\n反向代理 反向代理的作用主要是为服务器做缓存和负载均衡。这里不做过多讨论，感兴趣的朋友可以看 这里。顺带一提，shadowsocks 里也有负载均衡的概念，但 shadowsocks 的负载均衡和反向代理的负载均衡不是一个概念。\n反向代理的负载均衡是指：在多个真正的服务器前架设一个代理服务器，用户所有的数据都发给代理服务器，然后代理服务器根据各个真实服务器的状态将数据转发给一个任务较少的服务器处理。这样，服务商既可以架设多个服务器分担任务、减轻压力，用户也只要记一个域名或 ip 就可以了。\n而 shadowsocks 的负载均衡是指：每隔一段时间更改一次翻墙服务器，将用户的数据平均发给多个不同的翻墙服务器，以避免发往某一个翻墙服务器的流量过多。\nshadowsocks 最后，就是我们的 shadowsocks 闪亮登场了。介绍之前，我这里先附上 shadowsocks 的 官网链接。英文比较好的同学建议看看官网上对 shadowsocks 的介绍。\n在 shadowsocks 之前，墙内网民主要依靠寻找现成的技术实现翻墙。比如 vpn、HTTPS、tor 的中继网桥以及之后的 meek 插件等等，虽然也有自己的技术，比如一种依靠 Google 隐藏 ip 实现翻墙的技术（名字忘了）, 但毕竟难成大器，再加上 GFW 逐渐加大对 VPN 的干扰，人们迫切需要一种简单可靠的技术来抵御 GFW 的进攻。\n于是，大概是在 2013 年吧（具体时间我也不太清楚），@clowwindy 带着他的 shadowsocks 横空出世。Shadowsocks 同样是一种代理协议，但是作为 clowwindy 为国人设计的专门用于翻墙的代理协议，相对于 vpn，shadowsocks 有着极强的隐匿性；相对于 HTTP 代理，shadowsocks 提供了较为完善的加密方案，虽然比不上 HTTPS 代理和 vpn，但使用的也是成熟的工业级的加密算法，普通个人用户完全不用顾虑；相对于 HTTPS 代理，shadowsocks 的安装配置更为简单，中文社区更为活跃，中文文档教程更完善，更符合中国国情。\nShdadowsocks 最初的版本是由 clowwindy 使用 Python（一种目前非常热门的脚本编程语言）实现的。所以 clowwindy 的版本被称为 Python 版。shadowsocks 有点名气之后，不同的开发者使用不同的编程语言为其写了很多分支版本。比如，@cyfdecyf开发维护的 Go 版本，@madeye开发维护的 libev 版本（由纯 C 语言编写，基于 libev 库开发），由 @librehat 开发维护的 c++ 版，由 @zhou0 开发维护的 Perl 版。这些版本的安装使用指南都可以在 shadowsocks 的官网上查阅。\n2015 年，clowwindy 因喝茶事件被迫停止了 shadowsocks 的维护，并删除了其开源在 GitHub 上的代码，Python 版就此停滞。但其它版本仍处于维护更新中。其中，更新最频繁，新技术跟进最快的是由 @madeye 维护的 libev 版本。这里有必要说明下，目前，shadowsocks 协议（请区分 “shadowsocks 协议” 和“shadowsocks 协议的具体实现”这两者的区别）是由 shadowsocks 社区内的成员共同维护，协议上任何新改进都是社区成员共同商讨的结果。但对这些变化，不同的版本的 shadowsocks 跟进速度不同。而跟进速度最快的就是我上面说的 libev 版。无论是 SIP007 确认的 ADEA Ciphers（一种同时进行认证和加密的算法），还是 SIP003 引进的 simple-obfs（tor 开发的一种混淆插件），shadowsocks-libev 都是最早引入自己软件的。\nshadowsocks 是 c/s 架构，shadowsocks 的客户端则就是百花齐放了，有我们现在用的小飞机（Shadowsocks），ClashX，移动端等等。\n机场 随着 GFW 的不断升级，其实 shadowsocks 流量也会被检测出来，导致部署 shadowsocks 的服务器 IP 被封禁。其实 shadowsocks 还只是众多科学上网协议中的一种，其实还有 ssr（ShadowsocksR），v2ray（改善了 shadowsocks 的一些缺点，更难被 GFW 检测到，不过配置复杂），Trojan（上文提到过，模仿 https 流量，隐蔽性更强）。\n由于自己购买国外的 vps 部署的协议随着 GFW 的不断升级是有可能被识别到导致封 IP 的，如果 vps 提供商不支持更换 IP，那么你这台 vps 就浪费了。如果不想被封就需要不断学习新的隐蔽性更好的协议，所以对于个人用户来说，学习成本很高。\n这时候，机场服务就应运而生，只需要少量的付费，通过一条订阅就可以拿到上百条支持各种协议的线路，即使是那个节点被封，那随便切换一条就行。如今对于普通用户来说，机场已经成为了最多的科学上网方式。\n总结  vpn 是是一种加密通讯技术，它的核心技术是在加密，防窃听上。由于 GFW 刚上的时候 vpn 这项技术成熟，vpn 被迫营业，充当起了第一代翻墙手段。 shadowsocks 闪亮登场，有着很强的隐蔽性，配置简单 GFW 不断升级，更多的隐蔽性强的协议 v2ray，Trojan 机场服务，通过订阅拿到上百条线路，并且协议齐全，如果你不太想折腾并且不追求极致，机场服务是个不错的选择。  参考  https://github.com/sxcool1024/freedom https://github.com/shadowsocks  ","date":"2021-03-20T00:00:00Z","permalink":"https://aladdinding.cn/post/%E6%B5%85%E8%B0%88-vpnproxyshadowsocks%E6%9C%BA%E5%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB/","title":"浅谈 vpn、proxy、shadowsocks、机场之间的联系和区别"},{"content":"终端快捷键 快捷键应该是每一个需要和终端天天打交道的程序员必备的技能了，如果你还停留在每次前后左右一个字符一个字符移动光标的话，那你需要好好学习下面的终端快捷键，这可以大大提高你的效率\n最常用  tab 命令或路径的补全键  移动光标  Ctrl + a/Home 切换到命令行开始 Ctrl + e/End 切换到命令行末尾 Ctrl + f 光标向右移动一个字符（相当于方向键右键） Ctrl + b 光标向右移动一个字符（相当于方向键左键）  剪切、粘贴、清除  Ctrl + l 清除屏幕内容，效果等同于 clear 命令 Ctrl + u 清除剪切光标之前的内容 Ctrl + k 剪切清除光标之后的内容 Ctrl + y 粘贴刚才所删除的字符 Ctrl + w 剪切光标所在处之前的一个词（以空格、标点等为分隔符） Ctrl + h 删除光标所在处的前一个字符（相当于退格键） Ctrl + t 颠倒光标所在处及其之前的字符位置，并将光标移动到下一个字符 Alt + t 交换当前与以前单词的位置 Alt + d 剪切光标之后的词  控制快捷键  Ctrl + c 终止命令 Ctrl + s 锁住终端 Ctrl + q 解锁终端 Ctrl + z 转入后台运行, 但在当前用户退出后就会终止 Ctrl + d 退出 shell，logout Ctrl +（x u） 按住 Ctrl 的同时再先后按 x 和 u，撤销刚才的操作  重复执行命令、查找历史命令  Ctrl + o 重复执行命令 Ctrl + r 在历史命令中查找 （这个非常好用，输入关键字就调出以前的命令了） history 显示你所有执行过的编号 + 历史命令。这个可以配合 !n（n 是编号）来执行某某历史命令 !! 重复执行最后一条命令 (有四种方法)  使用上方向键，并回车执行。 按 !! 并回车执行。 输入 !-1 并回车执行。 按 Ctrl+P 并回车执行。   !$ 显示系统最近的一条参数（最后这个比较有用，比如我先用 cat /etc/hosts，然后我想用 vim 编辑。 一般的做法是先用↑ 显示最后一条命令，然后用 Home 移动到命令最前，删除 cat，然后再输入 vim 命 令。其实完全可以用 vim !$ 来代替） cd - 回到前一个工作路径  推荐文档 熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。\n《命令行的艺术》\n","date":"2020-08-21T00:00:00Z","permalink":"https://aladdinding.cn/post/linux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/","title":"Linux 命令行快捷键"},{"content":"Linux将整个文件系统看做一棵树，这棵树的树根叫做根文件系统，用/表示。\n   目录 全称 备注     /bin binaries 存放着只曾哥系统必须的二进制或可执行文件   /sbin system binaries 存放只能由root用户运行的系统二进制文件   /lib library 二进制文件的公共库   /usr unix system resources 与根目录结构类似，存放不是操作系统必须的二进制文件或应用程序，面向最终用户，centos7中/bin-\u0026gt;/usr/bin, /sbin-\u0026gt;/usr/sbin   /etc editable text config 存放配置文件   /home  存放不同用户的文件、配置和软件   /boot  系统启动所需文件，如linux内核   /dev device 包含设备文件，可以像管理普通文件一样管理硬件或者驱动程序   /opt optional 包含软件或者软件包   /var variable 存放操作系统运行过程中发生变化的文件，如系统日志或缓存文件   /tmp temporary 存放临时文件，系统会定期或目录大小到达一定上线后自动清理   /proc processes 正在运行的内核信息映射，主要包括进程信息、内存资源信息、磁盘分区信息等。（虚拟文件系统，不占内存）   /lost+found Lost+Found 这个目录在大多数情况下都是空的。但是如果你正在工作突然停电，或是没有用正常方式关机，在你重新启动机器的时候，这里就存放了一些文件。   /srv service 存放一些对外的服务数据（不是软件，而是数据），如web、ftp、流媒体等   /media  linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。   /mnt  系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容    ","date":"2020-08-11T00:00:00Z","permalink":"https://aladdinding.cn/post/linux%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%A4%87%E5%BF%98/","title":"Linux系统目录结构备忘"},{"content":"本文只代表个人见解，不代表任立场，如果您认为我的想法是错的那很正常，因为这是我的想法，如果您觉得您的想法和我一样，那我们就是传说中的 \u0026ldquo;激友\u0026rdquo;（对生活冲满激情的朋友）。进入正题。\n一、我心中的博客 我所以指的写博客，不单只是写一篇文章出来这一结果。而应该是写的这一过程，写过技术文章的朋友应该跟我一样有这么一个过程。\n  自己了解学习，文章所涉及到的知识点，及知识点衍生出来的知识点。\n  对学习的知识点进行验证，以确保理论值与实践值保持一致。\n  构思文章的大纲，哪些部分需要重点写，需要配合实例代码，图片等信息。\n  动手写，写完后再次检查校正并排版，然后发表。\n  针对网友的评论中提出的问题进行回复\n  我写文章一般都会经历以上 5 上步，最终以上 5 步融合成一个结果那就是 \u0026ldquo;一篇文章\u0026rdquo; 这一过程也是我心中对的 \u0026ldquo;写博客\u0026rdquo; 一词的诠释\n二、为什么要写博客 为自己 写博客对自己的提升是很大的，可能写一篇体现不出来，但是只要你坚持写效果就很明显，好处人个认为有以下几点\n强化知识点 在写一篇文章前，你必定是要把以文章中心为主的知识点及衍生的知识点都详细了解一篇，在这一过程中必须会涉及到自己以前所了解过的知识。\n人的记忆是存在记忆曲线的需要不断的重复记忆才能长久的记住某一事物，而每写一篇文章时都会查阅资料，在这一过程中必然会遇到以前记住了而现在渐渐淡忘的知识点。\n当你再次看到时瞬间就会回想起，此时以前的知识点就得到了强化。\n提升学习能力 同一样的人，了解同一知识点，用不同的方法，产生的结果必然会不一样。\n找到最佳的学习方法，这也是一种能力，这种能力是经过多次实践探索之后总结出来的。\n以前我每次需了解某一种技术时都会先百度看各种搜索结果，发现没有想要的之后，再 Google 因为 Google 的结果与百度的会有所不同，Google 结果中国外的文章相对会多一点。\n而偶然点了一个链接进入了博客园，发现就是自己想要的东西，而且把概念，代码，及经验都写上去了，看完之后对我帮助很大。\n渐渐的我便开始采这种方法了解新知识概念性的直接看百度百科，实质性的直接 上博客园的 找找看 。\n群里的朋友还推荐了一种方法，比如我要学 MVC 园子里很多人都写了 关于 MVC 的一系列文章，把那一系列的文章都看一遍，对于 MVC 就基本有了了解了，这便是学习能力的提升, 对于某种技术用最短的时间做到了比较全面的了解。\n提升文字组织能力 这个就不用说了，写博客，既然是写，就必然会有大量的文字，而如何组织文字表达出自己想表达的意思，是长期练习的，而写博客正好帮助你提高了你的文字组织能力。\n提升逻辑思维能力 不用说，技术性的东西从来就没的单独存在的，都一层层技术相结合，那在了解某种技术时，自己的思维也是要顺着这种关系逐渐深入的。\n比如 MVC，你不能只知道 M 是什么 V 是什么 C 是什么就行了吧，你得知道 M V C 这三者关系是怎样的，又是怎样交互，而你了解之后再把它写出来时，需要清晰逻辑。\n为他人 有意的 园子里有很多人都写过关于 MVC 框架 WCF 等等系列文章，目的就在于帮助新人快速上手，这个我深有体会，当初我开始学习 MVC 时就是看的 T2 噬菌体的 MVC 系列文章，整篇看完后再配合自己动手对于 MVC 就有了基本的了解了，在次感谢园子里无私献的大牛们。而以上行为就是有意的帮助。\n无意的 很多时候在开发项目的过程中，遇到了技术问题，花了时间解决后，有人会写博客记录，并附上解决方法旨在当再次遇到问题时直接看下文章就知道如何处理了。\n而碰巧的是，这种问题不止他一个人遇到了，很多人在开发时也遇到了这个问题。\n在网上找答案时，就找到了这篇文章，并根据文章提供的解决方法，顺利的解决了问题，这种帮助就是无意的帮助。\n三、一定要写博客吗 答案肯定是否定的，中国几百万的程序员，如果都写博客，那程序员的春天就来了，但是事实并非如此。\n而我所讲的 写博客 的产物并不只是一篇文章，更多的是，对自己能力的提升，自己对知识点的总结。\n而发表在博客上只是为了公开，还有很多人喜欢记录在云笔记里面。还有工作很忙，没有空闲时间写出来，因为写技术性的文章，花的时间是很长的。写过的朋友都知道。\n四、博客会给你带来哪些收获 古人云：一份耕耘，一份收获\n以下这些是帮助他人而得到的一些认可，并非主观上去追求的\nMVP：微软每年都颁发 MVP 给那些经常与其他专业人士分享知识和专业技能，受人尊敬、信任，而且平易近人的专家。而这个称号则是对你写的博客质量的肯定。\n知名度: 文章写得好的人，技术水平肯定也很好，知道的人多了，知名度就有了，比如园子里排名前 10 的大家都知道，都看过他们的文章。\n尊敬：对于技术界的大神，都是受人敬仰的，在园子里或者工作中也是一样的，在心里对大神们都是默默的佩服！至少我是这样啦，哈哈~ 也是我学习的榜样！\n五、总结 我所认的写博客是对自己所了解知识的强化，分享，自身能力的提升。当然 写 博客只是一种方法而已，只要能达到提升自我的效果什么方法都是可以的。\n之前有看过一则新闻：即便没有读者，你也要写博客 ，文章也讲解了很多写博客的好处。\n而我写博客是希望，能提升自己的综合能力，并把自己的知识与经验分享给大家，如果有幸我的分享帮助了一些人，那将使我更加欣慰。\n最后附上一句名言：有些事情你现在不去做，可能以后都不会有机会了！\n 转载自：https://mp.weixin.qq.com/s/gBx0SapuMyOY9Gu6gCoaag\n原作者：Zery\n ","date":"2020-08-09T00:00:00Z","permalink":"https://aladdinding.cn/post/%E4%BD%9C%E4%B8%BA%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2/","title":"作为技术人员为什么要写博客"},{"content":" SOCKS 是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS 是 \u0026ldquo;Socket Secure\u0026rdquo; 的缩写。当防火墙后的客户端要访问外部的服务器时，就跟 SOCKS 代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。这个协议最初由 David Koblas 开发，而后由 NEC 的 Ying-Da Lee 将其扩展到 SOCKS4。最新协议是 SOCKS5，与前一版本相比，增加支持 UDP（用户数据报协议）、验证，以及 IPv6。根据 OSI 模型，SOCKS 是 会话层 的协议，位于 表示层 与 传输层 之间。SOCKS 协议不提供 加密。\n SOCKS5 SOCKS 协议版本认证 创建与 SOCKS5 服务器的 TCP 连接后客户端需要先发送请求来确认协议版本及认证方式（以字节为单位）\nclient send 1 2 3 4 5  # +----+----------+----------+ # |VER | NMETHODS | METHODS | # +----+----------+----------+ # | 1 | 1 | 1 to 255 | # +----+----------+----------+    VER：SOCKS5 协议版本 0x05 NMETHODS：METHODS 所占字节长度 METHODS：客户端支持的认证方式列表，每个方法占 1 字节  0x00 不需要认证 0x01 GSSAPI 0x02 用户名、密码认证 0x03 to 0x7F 由 IANA 分配（保留） 0x80 to 0xFE 私人方法保留 0xFF 无可接受的方法    服务器从客户端提供的 METHODS 中选择一个并通过以下消息通知客户端\nserver reply 1 2 3 4 5  # +----+--------+ # |VER | METHOD | # +----+--------+ # | 1 | 1 | # +----+--------+     VER：协议版本 0x05\n  METHOD：服务端选中的方法。如果返回 0xFF 表示没有一个认证方法被选中，客户端需要关闭连接。\n  SOCKS 用户名密码认证 如果 SOCKS 协议版本认证中服务端返回的 METHOD 是 0x02，即需要用户名密码认证，则客户端会发送用户名密码认证信息。如果返回的 METHOD 是 0x00，即不需要认证，直接跳转下一步发送 SOCKS 请求信息。\nclient send 1 2 3 4 5  # +----+------+----------+------+----------+ # |VER | ULEN | UNAME | PLEN | PASSWD | # +----+------+----------+------+----------+ # | 1 | 1 | 1 to 255 | 1 | 1 to 255 | # +----+------+----------+------+----------+    VER：认证协议版本 0x01 ULEN：用户名长度 UNAME： 用户名 PLEN：密码长度 PASSWD：密码  server reply 1 2 3 4 5  # +----+--------+ # |VER | STATUS | # +----+--------+ # | 1 | 1 | # +----+--------+    VER：认证协议版本 0x01 STATUS：认证状态  0x00 成功 0x01 失败    发送 SOCKS 请求信息 认证结束后客户端就可以发送请求信息。如果认证方法有特殊封装要求，请求必须按照方法所定义的方式进行封装。\nclient send 1 2 3 4 5  # +----+-----+-------+------+----------+----------+ # |VER | CMD | RSV | ATYP | DST.ADDR | DST.PORT | # +----+-----+-------+------+----------+----------+ # | 1 | 1 | X\u0026#39;00\u0026#39; | 1 | Variable | 2 | # +----+-----+-------+------+----------+----------+    VER：SOCKS5 协议版本 0x05 CMD：SOCK 命令码  0x01 CONNECT 请求 0x02 BIND 请求 0x03 UDP 转发   RSV：0x00 保留 ATYP：DST.ADDR 类型  0x01 IPv4 地址，DST.ADDR 部分 4 字节长度 0x03 域名，DST.ADDR 部分第一个字节为域名长度，DST.ADDR 剩余的内容为域名，没有 \\ 0 结尾。 0x04 IPv6 地址，16 个字节长度。   DST.ADDR：目的地址 DST.PORT：网络字节序表示的目的端口  server reply 1 2 3 4 5  # +----+-----+-------+------+----------+----------+ # |VER | REP | RSV | ATYP | BND.ADDR | BND.PORT | # +----+-----+-------+------+----------+----------+ # | 1 | 1 | X\u0026#39;00\u0026#39; | 1 | Variable | 2 | # +----+-----+-------+------+----------+----------+    VER：SOCKS5 协议版本 0x05 REP：应答字段  0x00 成功 0x01 常规 SOCKS 服务器连接失败 0x02 现有规则不允许连接 0x03 网络不可达 0x04 主机不可达 0x05 连接被拒 0x06 TTL 超时 0x07 不支持的命令 0x08 不支持的地址类型 0x09 to 0xFF 未定义   RSV：0x00 保留 ATYP：BND.ADDR 类型  0x01 IPv4 地址，DST.ADDR 部分 4 字节长度 0x03 域名，DST.ADDR 部分第一个字节为域名长度，DST.ADDR 剩余的内容为域名，没有 \\ 0 结尾。 0x04 IPv6 地址，16 个字节长度。   BND.ADDR：服务器绑定的地址 BND.PORT：网络字节序表示的服务器绑定的端口  当服务端返回 REP 应答字段为 0x00，即成功时，客户端和服务端之间进行数据透传，完成 SOCKS5 代理。\nSOCKS4 SOCKS 4 只支持 TCP 转发\n发送 SOCKS 请求信息 client send 1 2 3 4 5  # +----+------+----------+--------+----------+----------+ # |VN | CD | DSTPORT | DSTIP | USERID | NULL | # +----+------+----------+--------+----------+----------+ # | 1 | 1 | 2 | 4 | variable | 1 | # +----+------+----------+--------+----------+----------+    VN：SOCKS4 协议版本 0x04 CD：SOCK 命令码  0x01 CONNECT 请求 0x02 BIND 请求   DSTPORT：目的主机的端口 DSTIP：目的主机的 IP 地址 USERID：用户 USERID NULL：0x00  server reply 1 2 3 4 5  # +-------+-------+----------+-----------+ # | VN | CD | DSTPORT | DSTIP | # +-------+-------+----------+-----------+ # | 1 | 1 | 2 | 4 | # +-------+-------+----------+-----------+    VN：回复代码的版本，应为 0x00（注意不是 0x04) CD：SOCK 命令码  90(0x5a) 请求得到允许； 91(0x5b) 请求被拒绝或失败； 92(0x5c) 由于 SOCKS 服务器无法连接到客户端的 identd（一个验证身份的进程），请求被拒绝； 93(0x5d) 由于客户端程序与 identd 报告的用户身份不同，连接被拒绝。   DSTPORT：目的主机的端口（和请求包中相同） DSTIP：目的主机的 IP 地址（和请求包中相同）  当服务端返回 CD 字段为 90(0x5a)，即允许时，客户端和服务端之间进行数据透传，完成 SOCKS4 代理。\nSOCKS4a SOCKS4a 协议是 SOCKS4 的一个补丁版，可以在 SOCKS4a 代理服务器上完成 DNS 解析\n发送 SOCKS 请求信息 client send 1 2 3 4 5  # +----+------+----------+--------+----------+----------+------------+----------+ # |VN | CD | DSTPORT | DSTIP | USERID | NULL | HOSTNAME | NULL | # +----+------+----------+--------+----------+----------+------------+----------+ # | 1 | 1 | 2 | 4 | variable | 1 | variable | 1 | # +----+------+----------+--------+----------+----------+------------+----------+    DSTIP：0.0.0.x，其中 x 是非零，一般都为 1。（原文：such an address is inadmissible as a destination IP address and thus should never occur if the client can resolve the domain name） HOSTNAME：域名  其余字段和 SOCKS4 相同\nserver reply SOCKS4a 代理首先把 HOSTNAME 如：www.example.com 解析成对应的主机 IP 地址，并且和 IP 地址连接上，再向客户端发送和 SOCKS4 一样的响应。当服务端返回 CD 字段为 90(0x5a)，即允许时，客户端和服务端之间进行数据透传，完成 SOCKS4a 代理。\nSOCKS4，SOCKS4a 和 SOCKS5 的区别 比如浏览器使用 SOCKS4 代理访问 www.baidu.com，浏览器先用本地的 DNS 解析把 www.baidu.com 转换成对应的 IP 地址，然后向 SOCKS4 服务器发送报文。如果此时我们的电脑受限本地完成不了 DNS 解析，那怎么办呢？SOCKS4a 就是解决这样的问题的，客户端可以把域名发送到 SOCKS4a 服务器上完成 DNS 解析，发送的 DSTIP 则为 0.0.0.1 这样的假 IP，然后就是和 SOCKS4 一样进行数据转发。SOCKS5 代理和 SOCKS4 SOCKS4a 比，多了一个验证功能和 udp 代理的功能。\nSOCKS 协议 RFC  SOCKS4.protocol.txt and SOCKS4A.protocol.txt for SOCKS 4 and the SOCKS 4A extension, respectively. SOCKS5_rfc1928.txt and SOCKS5_rfc1929.txt for SOCKS 5, and SOCKS 5 Username/Password authentication.  ","date":"2020-07-19T00:00:00Z","permalink":"https://aladdinding.cn/post/socks-%E5%8D%8F%E8%AE%AE%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/","title":"SOCKS 协议交互流程记录"},{"content":"黑苹果和白苹果最大的区别其实在显示效果上。同样一个网页，白苹果的显示就会细腻很多，而黑苹果颗粒感非常严重，造成上述原因是因为大多数苹果设备的屏幕本身的分辨率很高，如果你的显示器分辨率达到视网膜级别的话，哪怕是黑苹果也是默认开启 HiDPI 的。So 本人的 2k 分辨率显示器就很尴尬了，下面记录一下开启 HiDPI 的过程。\nHiDPI 的概念 有关 retina 和 HiDPI 那点事\n总之 HiDPI 是苹果一个牛逼的显示技术，通过牺牲一定的分辨率实现更细腻的显示效果，这就是为什么 2K 显示器开启 HiDPI 的效果要比 1080P 好的原因了。\n黑苹果开启原生 HiDPI 终端中运行如下命令\n1  sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/xzhih/one-key-hidpi/master/hidpi.sh)\u0026#34;   如果出现 curl: (7) Failed to connect to raw.githubusercontent.com port 443:xxx，应该是被墙了，可以挂上梯子\n1  export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890   终端运行后选择相应分辨率重启即可生效！\nHiDPI 开启效果 可以看到 HiDPI 开启后，「显示器选项」里面的缩放显示如图所示。可随意选择缩放模式而且不会高糊，在显示上明显感觉图标颗粒感更小了，显示更加细腻了。\n","date":"2020-07-11T00:00:00Z","permalink":"https://aladdinding.cn/post/%E9%BB%91%E8%8B%B9%E6%9E%9C%E4%B8%80%E9%94%AE%E5%BC%80%E5%90%AF-hidpi/","title":"黑苹果一键开启 HiDPI"},{"content":" ApacheBench（ab）是用于对 Apache 超文本传输协议（HTTP）服务器进行基准测试的工具。ab 命令会创建很多的并发访问线程，模拟多个访问者同时对某一 URL 地址进行访问。它的测试目标是基于 URL 的，因此，既可以用来测试 Apache 的负载压力，也可以测试 nginx、lighthttp、tomcat、IIS 等其它 Web 服务器的压力。ab 命令对发出负载的计算机要求很低，既不会占用很高 CPU，也不会占用很多内存，但却会给目标服务器造成巨大的负载，其原理类似 CC 攻击。自己测试使用也须注意，否则一次上太多的负载，可能造成目标服务器因资源耗完，严重时甚至导致死机。\n ApacheBench 安装 macOS Mac 下自带 apache，查看版本：\n1  apachectl -v   查看 ab 版本:\n1  ab -V   Window Windows 系统 Apache：下载链接\nLinux Ubuntu\n1  apt-get install apache2-utils   CentOS\n1  yum -y install httpd-tools   ApacheBench 使用 Options ab 压力测试工具的用法，查看：\n1 2 3  ab -h # 或者 man ab   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  Usage: ab [options] [http[s]://]hostname[:port]/path Options are: -n requests Number of requests to perform # 在测试会话中所执行的请求个数（本次测试总共要访问页面的次数）。默认时，仅执行一个请求。 -c concurrency Number of multiple requests to make at a time # 一次产生的请求个数（并发数）。默认是一次一个。 -t timelimit Seconds to max. to spend on benchmarking This implies -n 50000 # 测试所进行的最大秒数。其内部隐含值是 - n 50000。它可以使对服务器的测试限制在一个固定的总时间以内。默认时，没有时间限制。 -s timeout Seconds to max. wait for each response Default is 30 seconds # 套接字超时之前要等待的最大秒数。默认值为 30 秒。在 2.4.4 及更高版本中可用。 -b windowsize Size of TCP send/receive buffer, in bytes # TCP 发送 / 接收缓冲区的大小，以字节为单位。 -B address Address to bind to when making outgoing connections # 建立传出连接时要绑定的地址。 -p postfile File containing data to POST. Remember also to set -T # 包含要发布的数据的文件。记住也要设置 - T。 -u putfile File containing data to PUT. Remember also to set -T # 包含数据到 PUT 的文件。记住也要设置 - T。 -T content-type Content-type header to use for POST/PUT data, eg. \u0026#39;application/x-www-form-urlencoded\u0026#39; Default is \u0026#39;text/plain\u0026#39; # 用于 POST / PUT 数据的内容类型标头，例如 application/x-www-form-urlencoded。默认值为 text/plain。 -v verbosity How much troubleshooting info to print # 设置详细级别 4 上方将在标题上显示信息，3 上方将显示响应代码（404、200 等），2 上方将显示警告和信息。 -w Print out results in HTML tables # 在 HTML 表格中打印出结果。默认表是两列宽，带有白色背景。 -i Use HEAD instead of GET # 做 HEAD 请求，而不是 GET。 -x attributes String to insert as table attributes # 用作的属性的字符串 \u0026lt;table\u0026gt;。插入属性。\u0026lt;table here \u0026gt; -y attributes String to insert as tr attributes # 用作的属性的字符串 \u0026lt;tr\u0026gt;。 -z attributes String to insert as td or th attributes # 用作的属性的字符串 \u0026lt;td\u0026gt;。 -C attribute Add cookie, eg. \u0026#39;Apache=1234\u0026#39;. (repeatable) # cookie-name=value 对请求附加一个 Cookie: 行。 其典型形式是 name=value 的一个参数对。此参数可以重复，用逗号分割。 -H attribute Add Arbitrary header line, eg. \u0026#39;Accept-Encoding: gzip\u0026#39; Inserted after all normal header lines. (repeatable) # 将额外的标头添加到请求。该参数是典型地在一个有效报头线的形式，含有一个冒号分隔的字段值对（即，\u0026#34;Accept-Encoding: zip/zop;8bit\u0026#34;）。 -A attribute Add Basic WWW Authentication, the attributes are a colon separated username and password. # 向服务器提供 BASIC 身份验证凭据。用户名和密码用单个: 分隔，并通过编码为 base64 的网络发送。无论服务器是否需要该字符串，都将发送该字符串（即，已发送所需的 401 身份验证）。 -P attribute Add Basic Proxy Authentication, the attributes are a colon separated username and password. # 在代理途中提供 BASIC 身份验证凭据。用户名和密码用单个: 分隔，并通过编码为 base64 的网络发送。不管代理是否需要它都将发送该字符串（即，已发送所需的 407 代理身份验证）。 -X proxy:port Proxyserver and port number to use # 使用代理服务器处理请求。 -V Print version number and exit # 显示版本号并退出。 -k Use HTTP KeepAlive feature # 启用 HTTP KeepAlive 功能，即在一个 HTTP 会话中执行多个请求。默认为 no KeepAlive。 -d Do not show percentiles served table. # 不要显示 “XX [ms] 表中的投放百分比”。（旧版支持）。 -S Do not show confidence estimators and warnings. # 当平均值和中位数相距标准偏差的一倍或两倍以上时，请勿显示中位数和标准偏差值，也不会显示警告 / 错误消息。并默认为最小值 / 平均值 / 最大值。（旧版支持）。 -q Do not show progress when doing more than 150 requests # 当处理 150 个以上的请求时，每 10％或 100 个左右的请求 ab 输出进度计数 stderr。该 -q 标志将禁止显示这些消息。 -l Accept variable document length (use this for dynamic pages) # 如果响应的长度不是恒定的，请不要报告错误。这对于动态页面很有用。在 2.4.7 及更高版本中可用。 -g filename Output collected data to gnuplot format file. # 将所有测量值写为 “gnuplot” 或 TSV（制表符单独值）文件。此文件可以轻松导入到 Gnuplot，IDL，Mathematica，Igor 甚至 Excel 等软件包中。标签位于文件的第一行。 -e filename Output CSV file with percentages served # 编写一个逗号分隔值（CSV）文件，其中包含为每个百分比（从 1％到 100％）提供该百分比请求所花费的时间（以毫秒为单位）。通常，它比 “gnuplot” 文件有用。因为结果已经 “装箱” 了。 -r Don not exit on socket receive errors. # 套接字接收错误时不退出 -m method Method name # 请求的自定义 HTTP 方法。在 2.4.10 及更高版本中可用。 -h Display usage information (this message) # 显示使用情况信息。 -I Disable TLS Server Name Indication (SNI) extension # 禁用 TLS 服务器名称指示 (SNI) 扩展 -Z ciphersuite Specify SSL/TLS cipher suite (See openssl ciphers) # 指定 SSL / TLS 密码套件（请参阅 openssl 密码） -f protocol Specify SSL/TLS protocol (SSL2, TLS1, TLS1.1, TLS1.2 or ALL) # 指定 SSL / TLS 协议（SSL2，SSL3，TLS1，TLS1.1，TLS1.2 或 ALL）。TLS1.1 和 TLS1.2 支持在 2.4.4 及更高版本中提供。 -E certfile Specify optional client certificate chain and private key # 指定可选的客户端证书链和私钥   Output 执行命令\n1  ab -n 1000 -c 200 http://pts.aliyun.com/lite/index.htm/   获取结果分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  # apache 版本信息 This is ApacheBench, Version 2.3 \u0026lt;$Revision: 1843412 $\u0026gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking pts.aliyun.com (be patient) Completed 100 requests Completed 200 requests Completed 300 requests Completed 400 requests Completed 500 requests Completed 600 requests Completed 700 requests Completed 800 requests Completed 900 requests Completed 1000 requests Finished 1000 requests # 请求返回 header 类型 Server Software: Tengine/Aserver # 请求 ip 或者域名 Server Hostname: pts.aliyun.com # 请求端口，当前请求为 https 所以端口为 443，请求 https 端口 80 Server Port: 80 # 从命令行字符串解析请求 URI。 Document Path: /lite/index.htm/ # 这是第一个成功返回的文档的大小（以字节为单位）。如果在测试过程中文档长度发生变化，则将响应视为错误。 Document Length: 357 bytes # 测试期间使用的并发客户端数 Concurrency Level: 200 从建立连接到最后接受完成总时间 Time taken for tests: 1.280 seconds # 完成请求数 Complete requests: 1000 # 失败请求数 Failed requests: 0 # 不在 200 系列响应代码中的响应数。如果所有响应均为 200，则不会打印此字段。 Non-2xx responses: 1000 # 从服务器接收的字节总数 Total transferred: 642000 bytes # HTML 接收字节数，减去了 Total transferred 中 HTTP 响应数据中的头信息的长度 HTML transferred: 357000 bytes # 吞吐率：每秒请求数（总请求数 / 总时间，相当于 LR 中的每秒事务数 TPS） Requests per second: 781.47 [#/sec] (mean) # 用户平均请求等待时间 Time per request: 255.928 [ms] (mean) # 服务器处理每个请求平均响应时间，mean 表示为平均值 Time per request: 1.280 [ms] (mean, across all concurrent requests) # 由公式计算得出的传输速率 totalread / 1024 / timetaken Transfer rate: 489.95 [Kbytes/sec] received # 连接消耗时间分解 Connection Times (ms) min mean[+/-sd] median max 最小值 平均值 标准差 中间值 最大值 Connect: 22 30 4.0 30 38 Processing: 22 95 164.5 34 1200 Waiting: 22 83 154.3 33 1200 Total: 46 125 163.4 66 1227 # 按完成请求的百分比，得出完成请求中花费时间最长的那一个请求的时间，也就是这些请求完成时间的最大值（毫秒） Percentage of the requests served within a certain time (ms) # 50% 请求完成时间的最大值是 66 毫秒 50% 66 66% 69 75% 71 80% 80 90% 317 # 90% 请求完成时间的最大值是 148 毫秒 95% 536 98% 744 99% 825 # // 100% 请求完成时间的最大值是 1227 毫秒（最长请求） 100% 1227 (longest request)   性能指标 1、吞吐率（Requests per second） 服务器并发处理能力的量化描述，单位是 reqs/s，指的是在某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。 记住：吞吐率是基于并发用户数的。这句话代表了两个含义： a、吞吐率和并发用户数相关； b、不同的并发用户数下，吞吐率一般是不同的。 计算公式：总请求数 / 处理完成这些请求数所花费的时间，即： Request per second=Complete requests/Time taken for tests 必须要说明的是，这个数值表示当前机器的整体性能，值越大越好。\n2、并发连接数（The number of concurrent connections） 并发连接数指的是某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。\n3、并发用户数（Concurrency Level） 要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。在 HTTP/1.1 下，IE7 支持两个并发连接，IE8 支持 6 个并发连接，FireFox3 支持 4 个并发连接，所以相应的，我们的并发用户数就得除以这个基数。\n4、用户平均请求等待时间（Time per request） 计算公式：处理完成所有请求数所花费的时间 /（总请求数 / 并发用户数），即：Time per request=Time taken for tests/（Complete requests/Concurrency Level）\n5、服务器平均请求等待时间（Time per request:across all concurrent requests） 计算公式：处理完成所有请求数所花费的时间 / 总请求数，即： Time taken for/testsComplete requests 可以看到，它是吞吐率的倒数。同时，它也等于用户平均请求等待时间 / 并发用户数，即： Time per request/Concurrency Level\n","date":"2020-05-26T00:00:00Z","permalink":"https://aladdinding.cn/post/apachebench-http-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","title":"ApacheBench HTTP 服务器基准测试工具使用总结"},{"content":"原文  Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren\u0026rsquo;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one\u0026ndash; and preferably only one \u0026ndash;obvious way to do it. Although that way may not be obvious at first unless you\u0026rsquo;re Dutch. Now is better than never. Although never is often better than right now. If the implementation is hard to explain, it\u0026rsquo;s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea \u0026ndash; let\u0026rsquo;s do more of those!\n 解读 The Zen of Python 是 Python 语言的指导原则，遵循这些基本原则，你就可以像个 Pythonista 一样编程。具体内容你可以在 Python 命令行输 import this 看到：\n  Beautiful is better than ugly.\n# 优美胜于丑陋（Python 以编写优美的代码为目标）\n  Explicit is better than implicit.\n# 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）\n  Simple is better than complex.\n# 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）\n  Complex is better than complicated.\n# 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）\n  Flat is better than nested.\n# 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）\n  Sparse is better than dense.\n# 间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）\n  Readability counts.\n# 可读性很重要（优美的代码是可读的）\n  Special cases aren\u0026rsquo;t special enough to break the rules. Although practicality beats purity.\n# 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）\n  Errors should never pass silently. Unless explicitly silenced.\n# 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）\n  In the face of ambiguity, refuse the temptation to guess.\n# 当存在多种可能，不要尝试去猜测\n  There should be one\u0026ndash; and preferably only one \u0026ndash;obvious way to do it.\n# 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）\n  Although that way may not be obvious at first unless you\u0026rsquo;re Dutch.\n# 虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido）\n  Now is better than never. Although never is often better than right now.\n# 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）\n  If the implementation is hard to explain, it\u0026rsquo;s a bad idea.\n# 如果你无法向人描述你的方案，那肯定不是一个好方案\n  If the implementation is easy to explain, it may be a good idea.\n# 如果你能向人简洁描述你的方案，那也许是一个好方案（方案测评标准）\n  Namespaces are one honking great idea \u0026ndash; let\u0026rsquo;s do more of those!\n# 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）\n  这首特别的 “诗” 开始作为一个笑话，但它确实包含了很多关于 Python 背后的哲学真理。Python 之禅已经正式成文 PEP 20，具体内容见：PEP 20\n","date":"2020-01-16T00:00:00Z","permalink":"https://aladdinding.cn/post/the-zen-of-python/","title":"The Zen of Python"},{"content":"Homebrew 简介  Homebrew 是一款 MacOS 平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。\n Homebrew 的几个核心概念 在正式介绍 Homebrew 的使用之前，我先为你介绍一下 Homebrew 中的一些核心的概念，了解这些概念，就可以帮助你更好的去使用 Homebrew。\n   词汇 含义     formula (e) 安装包的描述文件，formulae 为复数   cellar 安装好后所在的目录   keg 具体某个包所在的目录，keg 是 cellar 的子目录   bottle 预先编译好的包，不需要现场下载编译源码，速度会快很多；官方库中的包大多都是通过 bottle 方式安装   tap 下载源，可以类比于 Linux 下的包管理器 repository   cask 安装 macOS native 应用的扩展，你也可以理解为有图形化界面的应用。   bundle 描述 Homebrew 依赖的扩展    Homebrew 安装 将以下命令粘贴至终端，回车运行\n1  /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\u0026#34;   如果出现 curl: (7) Failed to connect to raw.githubusercontent.com port 443:xxx，应该是被墙了，挂上梯子即可\n1  export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890   Homebrew 更换国内源 替换默认源 1 2 3 4 5 6 7 8 9 10  # 步骤一：替换 brew.git cd \u0026#34;$(brew --repo)\u0026#34; git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git # 步骤二：替换 homebrew-core.git cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git #步骤三 brew update   替换 Homebrew Bottles 源  Homebrew 是 OS X 系统的一款开源的包管理器。出于节省时间的考虑，Homebrew 默认从 Homebrew Bottles 源中下载二进制代码包安装。Homebrew Bottles 是 Homebrew 提供的二进制代码包，目前镜像站收录了以下仓库：\n  homebrew/homebrew-core homebrew/homebrew-dupes homebrew/homebrew-games homebrew/homebrew-gui homebrew/homebrew-python homebrew/homebrew-php homebrew/homebrew-science homebrew/homebrew-versions homebrew/homebrew-x11  1 2  # 根据自己使用的 shell echo \u0026#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile   1 2  # 使配置生效 source ~/.bash_profile   复原默认源 1 2 3 4 5 6 7 8 9 10  # 步骤一 cd \u0026#34;$(brew --repo)\u0026#34; git remote set-url origin https://github.com/Homebrew/brew.git # 步骤二 cd \u0026#34;$(brew --repo)/Library/Taps/homebrew/homebrew-core\u0026#34; git remote set-url origin https://github.com/Homebrew/homebrew-core # 步骤三 brew update   Homebrew 常用命令 安装卸载软件  brew --version 或者 brew -v 显示 brew 版本信息 brew install 安装指定软件 brew unistall 卸载指定软件 brew list 显示所有的已安装的软件 brew search text 搜索本地远程仓库的软件，已安装会显示绿色的勾 brew search /text/ 使用正则表达式搜软件  升级软件相关  brew update 自动升级 homebrew（从 github 下载最新版本） brew outdated 检测已经过时的软件 brew upgrade 升级所有已过时的软件，即列出的以过时软件 brew upgrade 升级指定的软件 brew pin 禁止指定软件升级 brew unpin 解锁禁止升级 brew upgrade --all 升级所有的软件包，包括未清理干净的旧版本的包  清理相关  brew cleanup -n 列出需要清理的内容 brew cleanup 清理指定的软件过时包 brew cleanup 清理所有的过时软件 brew unistall 卸载指定软件 brew unistall --force 彻底卸载指定软件，包括旧版本  服务相关   brew services start mysql 启动 Mysql\n  brew services stop mysql 停止 Mysql\n  brew services restart mysql 重启 Mysql\n  brew services list 查看启动列表\n  ","date":"2020-01-05T00:00:00Z","permalink":"https://aladdinding.cn/post/macos-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E7%AE%A1%E7%90%86%E5%99%A8-homebrew/","title":"MacOS 软件包的管理器 Homebrew"},{"content":"这几天整理了大学期间的书籍，发现了当时选修日语课时自己总结打印出来的的日语五十音巧记，现在看到还有点好笑，不过当时确实帮助自己应付过了期末考试。直到现在两年过去了，自己还是可以背出日语五十音前面几十个，这里就记录一下吧，万一以后有用呢。。。\nあ行     清音     あア \u0026ldquo;女\u0026rdquo; 孩子胖 \u0026ldquo;了\u0026rdquo; 一圈, 惨叫了一声 \u0026ldquo;啊 (a)\u0026rdquo;   いイ 平假名い和片假名イ拼在一起就会组成一个汉字 \u0026ldquo;以 (i)\u0026quot;，读音也是以   うウ 平假名う很像字母 W 横过来,\u0026ldquo;屋 (u)\u0026rdquo;, 片假名ウ像“家” 字的宝盖头, 有家有房 \u0026ldquo;屋\u0026rdquo;   えエ \u0026ldquo;元\u0026rdquo; 朝的 \u0026ldquo;工\u0026rdquo; 人很悲 \u0026ldquo;哀 (e)\u0026rdquo;   おオ 有学 “术” 的“才”子都很 \u0026ldquo;傲(o)\u0026rdquo; 气    か行     清音 浊音     かカ 因为被 \u0026ldquo;卡 (ka)\u0026rdquo; 住了，所以要多用 \u0026ldquo;一点\u0026rdquo;\u0026rdquo; 力 \u0026quot; ga( が ガ)   きキ 长得像琵琶, 琵琶调音 key(ki) gi( ぎ ギ)   くク 小时候 \u0026ldquo;小于\u0026rdquo; 别人, 长大后终于 \u0026ldquo;大于\u0026rdquo; 别人, 感动的要 “哭(ku)” 了 gu( ぐ グ)   けケ \u0026ldquo;开 (ke)\u0026rdquo; 了一 \u0026ldquo;个\u0026rdquo; 豆 \u0026ldquo;汁\u0026rdquo; 店 ge( げ ゲ)   こコ \u0026ldquo;扣 (ko)\u0026rdquo; 了“两条鱼” 放在鱼篓里 go( ご ゴ)    さ行     清音 浊音     さサ 一个人弯着腿跪在 \u0026ldquo;艹\u0026rdquo; 上面, 是不是很 \u0026ldquo;傻 (sa)\u0026rdquo; za( ざ ザ)   しシ 用 “吸管” 喝水,\u0026ldquo;吸(shi)\u0026rdquo; 出来“三点水 ji( じ ジ)   すス 一个人上吊 \u0026ldquo;又\u0026rdquo;\u0026quot; 苏 (su)\u0026quot; 醒了 zu( ず ズ)   せセ 世界被 \u0026ldquo;塞 (se)\u0026rdquo; 得满满的 ze( ぜ ゼ)   そソ 一位艺人比起了 V 字 \u0026ldquo;手 (so)\u0026rdquo; zo( ぞ ゾ)    た行     清音 浊音     たタ \u0026ldquo;他 (ta)\u0026rdquo; 在半夜 \u0026ldquo;十二\u0026rdquo; 点的 \u0026ldquo;夕\u0026rdquo; 阳下 da( だ ダ)   ちチ \u0026ldquo;吃 (chi)\u0026ldquo;5 千个包子 ji( ぢ ヂ)   つツ 好 \u0026ldquo;粗 (tsu)\u0026rdquo; 的一根绳子打了三个结 zu( づ ヅ)   てテ 路人 \u0026ldquo;乙\u0026rdquo; 撞到了 \u0026ldquo;行\u0026rdquo; 人老 \u0026ldquo;太太 (te)\u0026rdquo; de( で デ)   とト \u0026ldquo;丫\u0026rdquo; 头 \u0026ldquo;拖 (to)\u0026rdquo; 着一个萝 \u0026ldquo;卜\u0026rdquo; do( ど ド)    な行     清音     なナ 把 \u0026ldquo;十三\u0026rdquo; 算成了 \u0026ldquo;十\u0026rdquo; 也太木 \u0026ldquo;讷 (na)\u0026rdquo; 了   にニ \u0026ldquo;你 (ni)\u0026rdquo; 是 \u0026ldquo;仁\u0026rdquo; 者 \u0026ldquo;二\u0026rdquo; 心   ぬヌ \u0026ldquo;奴 (nu)\u0026rdquo; 隶制度 \u0026ldquo;又\u0026rdquo; 出现了   ねネ 有了 \u0026ldquo;权\u0026rdquo; 利的奶 (n) 奶是 \u0026ldquo;福\u0026rdquo; 气   のノ \u0026ldquo;NO(no)\u0026ldquo;\u0026ldquo;0\u0026quot;和\u0026quot;1\u0026rdquo;    は行     清音 浊音 半浊音     はハ \u0026ldquo;哈 (ha)\u0026rdquo; 八巴狗打 \u0026ldquo;仗\u0026rdquo; ba( ば バ) pa( ぱ パ)   ひヒ \u0026ldquo;黑 (hi)\u0026rdquo; 色的 \u0026ldquo;U\u0026rdquo; 型 \u0026ldquo;匕\u0026rdquo; 首 bi( び ビ) pi( ぴ ピ)   ふフ \u0026ldquo;小\u0026rdquo;\u0026rdquo; 夫 (fu)\u0026ldquo;子玩\u0026rdquo; 飞刀 \u0026quot; bu( ぶ ブ) pu( ぷ プ)   へヘ 太 \u0026ldquo;嗨 (he)\u0026rdquo; 了两个眼睛都笑弯了 be( べ ベ) pe( ぺ ペ)   ほホ 对着 \u0026ldquo;木\u0026rdquo; 头 \u0026ldquo;\u0026lsquo;吼 (ho)\u0026rdquo; 了 \u0026ldquo;一天\u0026rdquo; bo( ぼ ボ) po( ぽ ポ)    ま行     清音     まマ \u0026ldquo;天\u0026rdquo; 天玩 \u0026ldquo;飞刀\u0026rdquo;” 吗 (ma)\u0026rdquo;   みミ \u0026ldquo;三\u0026rdquo; 个 \u0026ldquo;H\u0026rdquo;\u0026rdquo; 眯 (mi)\u0026rdquo; 着眼   むム \u0026ldquo;跪在\u0026rdquo; 木 (mu)\u0026ldquo;头上上吊\u0026rdquo; 么 \u0026quot;   めメ 一个 \u0026ldquo;女\u0026rdquo; 的被 × 后被 “灭 (me)\u0026quot; 了   もモ \u0026ldquo;七\u0026rdquo; 个 \u0026ldquo;毛\u0026rdquo; 子有阴 \u0026ldquo;谋 (mo)\u0026rdquo;    や行     清音     やヤ 两个 \u0026ldquo;牙 (ya)\u0026rdquo;\u0026quot; 也 \u0026quot; 坏了   ゆユ \u0026ldquo;有 (yu)\u0026rdquo;\u0026quot; 一串糖葫芦 \u0026ldquo;用\u0026rdquo; 长篓子 \u0026quot; 装起来   よヨ \u0026ldquo;哟 (yo)\u0026rdquo; \u0026ldquo;支\u0026rdquo; 付宝 \u0026ldquo;扫\u0026rdquo; 码    ら行     清音     らラ \u0026ldquo;今\u0026rdquo; 天 \u0026ldquo;5\u0026rdquo; 个人 \u0026ldquo;拉 (ra)\u0026rdquo; 肚子   りリ 两个像 \u0026ldquo;立 (ri)\u0026rdquo; 刀旁 \u0026ldquo;刂\u0026rdquo;   るル \u0026ldquo;路 (ru)\u0026rdquo; 上遇到 \u0026ldquo;儿\u0026rdquo; 子 \u0026ldquo;歹\u0026rdquo; 徒   れレ 有 \u0026ldquo;机\u0026rdquo; 会 \u0026ldquo;来 (re)\u0026rdquo; 要 \u0026ldquo;勾\u0026rdquo; 住   ろロ \u0026ldquo;3\u0026rdquo; 万人 \u0026ldquo;口\u0026rdquo; 好 \u0026ldquo;low(ro)\u0026rdquo;    わ行     清音     わワ \u0026ldquo;水箱的底儿没了\u0026rdquo;, 水 \u0026ldquo;哇 (wa)\u0026rdquo; 的全漏光了   をヲ 龙 \u0026ldquo;哦 (o)\u0026rdquo;    拨音     清音     んン \u0026ldquo;摁 (n)'\u0026rdquo; 两下 \u0026ldquo;\u0026ldquo;铃铛\u0026rdquo;    ","date":"2020-01-05T00:00:00Z","permalink":"https://aladdinding.cn/post/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E7%AC%A8%E6%8B%99%E8%AE%B0%E5%BF%86/","title":"日语五十音笨拙记忆"},{"content":"SSH 简介  SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 最初是 UNIX 系统上的一个程序，后来又迅速扩展到其他操作平台。SSH 在正确使用时可弥补网络中的漏洞。SSH 客户端适用于多种平台。几乎所有 UNIX 平台—包括 HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行 SSH。SSH 登录提供两种认证方式：口令 (密码) 认证方式和密钥认证方式。其中口令 (密码) 认证方式是我们最常用的一种，这里介绍密钥认证方式登录到 linux/unix 的方法。\n SSH 服务器之间免密登陆配置 生成密钥（公钥和私钥） 1 2 3  cd $HOME/.ssh ssh-keygen -t rsa # 全部回车默认   参数 -t rsa 表示使用 rsa 算法进行加密，执行后，会在 / home / 当前用户 /.ssh 目录下找到 id_rsa（私钥）和 id_rsa.pub（公钥）\n放置公钥到目标服务器中 1  cat id_rsa.pub   复制 id_rsa.pub 内的公钥，登陆到目标服务器\n1 2  cd $HOME/.ssh vi authorized_keys   将复制的公钥粘贴到 authorized_keys 中，authorized_keys 存放远程免密登录的公钥，主要通过这个文件记录多台机器的公钥\n 以上的步骤就已经完成了 SSH 服务器之间的免密登陆。不过有的场景是一台跳板机和多台服务器完成了 SSH 免密传输，此时想换一台电脑管理这些服务器，可以将之前的跳板机私钥拷贝到新电脑中。\n1  ssh-add ~/.ssh/id_rsa # id_rsa 为之前跳板机的私钥   如果出现提示 Could not open a connection to your authentication agent., 运行如下命令\n1  ssh-agent bash   GitHub 的免密传输 SSH 的免密传输  登陆到 Github 中，进入个人设置 提交服务器 SSH 公钥 选择 SSH and GPG keys，粘贴你的服务器公钥  切换项目的传输方式 1 2 3 4 5  # （以 HTTPS 切换成 SSH 为例） git remote remove origin git remote add origin git@github.com:Username/Your_Repo_Name.git # 重新设置 track branch git branch --set-upstream-to=origin/master master   HTTPS 的免密传输 新建文件 1  vi $HOME/.git-credentials   添加以下内容 1 2  # （GitHub 为 github.com，码云为 gitee.com） https://{username}:{password}@github.com   添加 git 配置 1  git config --global credential.helper store   查看是否添加成功 1 2 3  # 查看 $HOME/.gitconfig 文件，会发现出现一下内容 [credential] helper = store   这样设置存在一定风险，因为密码是明文存放在这个文件里的，比较容易泄露\n","date":"2019-10-09T00:00:00Z","permalink":"https://aladdinding.cn/post/ssh-%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE/","title":"SSH 相关的快速配置"},{"content":"前言 目前主流的计算机的确都是以二进制形式存储数据的。如 00100101（其中的 0 是一个 bit，1 也是一个 bit，这 8 个 bit 就是一个 byte）。通常为了更方便表示二进制数据，也可以转换成 16 进制表示出来，0010 0101 就可以用 16 进制的 0x25 来表示（1byte=2 个 16 进制位 = 8bit=8 个二进制位）。一个字节一共可以用来表示 256 种不同的状态（每一个状态对应一个符号，就是 256 个符号，从 00000000 到 11111111）\n字符集（character set）：规定了某个字符文字对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个文字（解码）的转换关系。\n字符编码（character encoding）：编码字符集和实际存储数值之间的转换关系，也就是字符转换成二进制数据的规则（要和对应关系区分）。\n英文编码 ASCII 码 ASCII（美国信息交换标准码）是美国国家标准定制的一套基于拉丁字母的电脑编码系统，可表示数字、字母等字符符号。一个 ASCII 码在计算机中由一个字节存储，因此它最多可表示 256 个符号（一个字节为 8 位，2 的 8 次方等于 256）。实事上，标准的 ASCII 编码时只用到了低 7 位 （最高位统一为 0，或者为奇偶校验位），故 ASCII 码可表示的数据一共只有 128 个（2 的 7 次方）。这 128 个字符中，其中 95 个为可显示字符（可打印字符，比如数字、字母、标点符号），还有 33 个如比如“换行” 之类的控制字符（控制字符主要是用来操控已经处理过的文字）。最后附上了 ASCII 码表：\n常用字符对应的 ASCII 编码：\n 回车，ASCII 码 13（十进制，下同） 换行，ASCII 码 10 空格，ASCII 码 32 数字 0 到 9，ASCII 依次是 48 到 57 大写字母 A 到 Z，ASCII 依次是 65 到 90 小写字母 a 到 z，ASCII 依次是 97 到 122  大小规则总结：\n 数字 0~9 比字母要小。如 \u0026ldquo;7\u0026rdquo;\u0026lt;\u0026ldquo;F\u0026rdquo; 数字 0 比数字 9 要小，并按 0 到 9 顺序递增。如 \u0026ldquo;3\u0026rdquo;\u0026lt;\u0026ldquo;8\u0026rdquo; 字母 A 比字母 Z 要小，并按 A 到 Z 顺序递增。如 \u0026ldquo;A\u0026rdquo;\u0026lt;\u0026ldquo;Z\u0026rdquo; 同个字母的大写字母比小写字母要小。如 \u0026ldquo;A\u0026rdquo;\u0026lt;\u0026ldquo;a\u0026rdquo;  ISO-8859-1 码（Latin-1） iso8859-1 通常叫做 Latin-1，它和 ascii 编码相似，都属于单字节编码，不同于 ASCII 的是，每个字节中的最高位也参与了编码（如果最高位为 0，它的意义同 ASCII）。正因为如此，iso8859-1 最多能表示的字符范围是 0-255，应用于英文系列。\n很明显，iso8859-1 编码表示的字符范围很窄，无法编码中文字符。尽管如此，我们可以先把中文字符按照其它的编码方式编码成二进制数据，然后将编码后的结果再逐字节逐字节的用 iso8859-1 解码。也就是说，中文字符，它没有 iso8859-1 编码，但可以在用其它编码方式编码后的基础上再用 iso8859-1 编码来表示。举个栗子，虽然 “中文” 的“中”这个字不存在 iso8859-1 编码，可以先把它按 gb2312 编码方式编码为 \u0026ldquo;d6d0\u0026rdquo; 这个二字节的编码（16 进制），然后将它拆开为两个字节（\u0026ldquo;d6\u0026rdquo; 与 \u0026ldquo;d0\u0026rdquo;），每个字节都可以看作是一个 iso8859-1 码。\niso8859-1 由于是单字节编码，和计算机最基础的表示单位一致，因此在很多网络传输协议上，默认使用 iso8859-1 编码。网络上传输的数据都是二进制的，服务器从网络 io 流中收到这些数据后，默认把每个字节的数据按 iso8859-1 编码来处理。\n实事上，通过网络流传输中文时，客户端可以先把中文字符按照其它的编码方式（比如 GBK 或 UTF-8）转换成字节数据发送到服务器，服务器收到后在不指定编码方式的情况下默认会逐个逐个字节的按照 iso8859-1 编码方式来解码。\n随着时间的推移，计算机在世界范围内传播开来中国，日本，韩国等等。这些国家都要设计自己的文字编码表，下面就要讲到中国的 GB 系列\n中文编码 GB2312 码 GB2312 是对 ASCII 的中文扩展，考虑到每个 ASCII 码只用了一个字节的底 7 位（高位为 0），所以每个的 ASCII 码都小于或等于 127（01111111）。\n于是规定：一个小于 127 的字符的意义与原来相同（为了兼容 ASCII 码），但两个大于 127 的字符连在一起时，就表示一个汉字，而且这两个字节中，前面的一个字节（他称之为高字节）从 0xA1 用到 0xF7，后面一个字节（低字节）从 0xA1 到 0xFE，这样我们可以组合出大约 7000 多个简体汉字，这就是 GB2312 编码。\n这样，计算机在解码时，可以逐字节逐字节的判断它的是否小于 127，如果小于或等于 127，就按 ASCII 直接解码，如果大于 127，就再往后多读取一个字节，如果后面那个字节也大于 127，就把这两个字节连起来再通过查找 GB2312 编码码表来解码成一个中文字符。由此可见，GB2312 码是一种变长的编码方式，英文占一个字节（而且小于 127），中文占两个字节（都是大于 127 的字节），而且兼容 ASCII 码。\nGBK 码 GB2312 码中用两个连续的大于 127 字节的数据来表示一个中文，它能表示的数量刚好也就满足简体中文编码的需要。\n后来发现，其实表示一个中文的两个字符中，可以不要求两个字节都大于 127，只要第一个字符大于 127，就可以作为解码中文的开始字符，第二个字符是否大于 127 都不会对计算机解码造成二义性错误（在逐字节解码的过程中，只要读到一个节字大于 127，就直接往后再读一个字节，不判断第二个字节是否大于 127 就直接将这两个字节连到一起然后再通过编码码表来解码）。\n这样，在 GB2312 码的基础上，通过不限定第二个字节是否大于 127 的方式扩展出了 GBK 码。GBK 包括了 GB2312 的所有内容，同时又增加了近 20000 个新的汉字（包括繁体字）和符号。\nGB18030 码 在 GBK 码的基础上，再进一步扩展，增加了一些连续四个字节的汉字，于是也就有了 GB18030 码，GB18030 码完全兼容 GBK 码，而且增加了少数民族文字综上所述，以上能表示中文的字符编码中，可编码的范围从小到大依次是：ASCII \u0026lt; GB2312 \u0026lt; GBK \u0026lt; GB18030，而且它们后者兼容前者，其中 GB2312 和 GB 用两个字节表示中文，GB18030 有些用两个字节表示一个汉字，有些有四个字节表示一个汉字。\n同样，香港台湾那边也对 ASCII 表进行扩充，设计了自己的表叫 BIG5。此外，日本（JIS）、韩国（KSC）也都有对应本国文字的表。上述为了扩充 [ASCII 编码](https://baike.baidu.com/item/ASCII 编码)，以于显示本国的语言，不同的国家和地区制定了不同的标准。\n这些使用 2 个 [字节](https://baike.baidu.com/item / 字节） 来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码，又称为 \u0026ldquo;MBCS（Muilti-Bytes Character Set，多字节字符集)\u0026quot;。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码，所以在中文 Windows 下要转码成 gb2312、gbk 只需要把文本保存为 ANSI 编码即可。\n不同 ANSI 编码之间互不兼容，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段 ANSI 编码的文本中。一个很大的缺点是，同一个编码值，在不同的编码体系里代表着不同的字。这样就容易造成混乱（也就是我们常说的乱码）。导致了 unicode 码的诞生。\n统一码（万国码） UNICODE 编码 因为每个国家都搞出像天朝这样一套自己的编码标准，在跨国跨语言使用时存在储多不便。为了统一，ISO（国际标谁化组织）重新搞了一套标准，也就是 UNICODE 编码。\nUNICODE 这是最统一的 定长 编码，有双字节编码（UCS-2）和四字节编码（UCS-4，备用）两种。其中 UCS-2 包括英文字母在内，只能表示 65535 个字符，IOS 预备的 UCS-4 方案，可以组合出 21 亿个不同的字符出来（最高位有其他用途）。\n其实，英文字母只用一个字节表示就够了，但是其他更大的符号可能需要 3 个字节或者 4 个字节，甚至更多。而 Unicode 统一规定，每个符号用两个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0，这对于存储来说其实是极大的浪费。\n而且它不兼容 iso8859-1 编码，也不兼容 gb2312、gbk、gb18030 等任何编码。不过，相对于 iso8859-1 编码来说，uniocode 编码只是在前面增加了一个 0 字节，比如字母 a 为 \u0026ldquo;00 61\u0026rdquo;。\n但是 UNICODE 这种定长编码便于计算机处理（注意 GB2312/GBK 不是定长编码），而 unicode 又可以用来表示所有字符，所以在很多软件内部是使用 unicode 编码来处理的，比如 java。\n需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。于是出现了多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 unicode。unicode 在很长一段时间内无法推广，直到互联网的出现。\nUTF UTF: Unicode TransferFormat，即把 Unicode 转做某种格式的意思。考虑到 unicode 编码不兼容 iso8859-1 编码，而且容易占用更多的空间：因为对于英文字母，unicode 也需要两个字节来表示。所以 unicode 不便于传输和存储。因此而产生了 utf 编码，utf 编码兼容 iso8859-1 编码，同时也可以用来表示所有语言的字符，不过，utf 编码是不定长编码，每一个字符的长度从 1-6 个字节不等。另外，utf 编码自带简单的校验功能。\nUTF-8 是 Unicode 的实现方式之一，一般来讲，对于 UTF-8，英文字母都是用一个字节表示，而汉字使用三个字节。另外，还有 UTF-16（字符用两个字节或四个字节表示）,UTF-32（字符用四个字节表示）。\n顾名思义，UTF-8 就是每次 8 个位传输数据，而 UTF-16 就是每次 16 个位。UTF-8 就是在互联网上使用最广的一种 unicode 的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。\nUTF-8 的编码规则很简单，只有二条：\n 对于单字节的符号，字节的第一位设为 0，后面 7 位为这个符号的 unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 对于 n 字节的符号（n\u0026gt;1），第一个字节的前 n 位都设为 1，第 n+1 位设为 0，后面字节的前两位一律设为 10。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。  综上所述，UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用 1~4 个字节表示一个符号，根据不同的符号而变化字节长度，可以加快传输速度和解决浪费。\n参考 十分钟搞清字符集和字符编码\n","date":"2019-10-02T00:00:00Z","permalink":"https://aladdinding.cn/post/%E6%90%9E%E6%B8%85%E6%A5%9A%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/","title":"搞清楚字符集和字符编码"},{"content":"Tmux 简介  Tmux 的全称是 Terminal MUtipleXer，及终端复用软件。顾名思义，它的主要功能就是用于在一个终端窗口中运行多个终端会话并且在你关闭终端窗口之后保持进程的运行。\n Tmux 安装 1 2 3 4 5 6 7 8  # Ubuntu 或 Debian $ sudo apt-get install tmux # CentOS 或 Fedora $ sudo yum install tmux # Mac $ brew install tmux   Tmux 概念 Tmux 中有几个重要概念：\n 会话（session）: 建立一个 tmux 工作区会话，会话可以长期驻留，重新连接服务器不会丢失，我们只需重新 tmux attach 到之前的工作区就可以恢复会话 窗口（window）: 容纳多个窗格 窗格（pane）: 可以在窗口中分成多个窗格   Tmux 基本操作 常用命令  tmux new　创建默认名称的会话 tmux new -s mysession　创建名为 mysession 的会话 tmux ls　显示会话列表 tmux a　连接上一个会话 tmux a -t mysession　连接指定会话 tmux rename -t s1 s2　重命名会话 s1 为 s2 tmux kill-session　关闭上次打开的会话 tmux kill-session -t s1　关闭会话 s1 tmux kill-session -a -t s1　关闭除 s1 外的所有会话 tmux kill-server　关闭所有会话  Tmux 默认的快捷键前缀是 ctrl+b，当然你也可以修改它（后文会提到） 以下所有的操作都是激活控制台之后，即键入 Ctrl+b 前提下才可以使用的命令\n会话操作（session）  ?　列出所有快捷键；按 q 返回 d　脱离当前会话, 可暂时返回 Shell 界面，输入 tmux attach 能够重新进入之前会话 s　选择并切换会话；在同时开启了多个会话时使用 D　选择要脱离的会话；在同时开启了多个会话时使用 :　进入命令行模式；此时可输入支持的命令，例如 kill-server 所有 tmux 会话 [　复制模式，光标移动到复制内容位置，空格键开始，方向键选择复制，回车确认，q/Esc 退出 ]　进入粘贴模式，粘贴之前复制的内容，按 q/Esc 退出 ~　列出提示信息缓存；其中包含了之前 tmux 返回的各种提示信息 t　显示当前的时间 Ctrl+z　挂起当前会话  窗口操作（window）  c　创建新窗口 \u0026amp;　关闭当前窗口 数字键　切换到指定窗口 p　切换至上一窗口 n　切换至下一窗口 l　前后窗口间互相切换 w　通过窗口列表切换窗口 ,　重命名当前窗口，便于识别 .　修改当前窗口编号，相当于重新排序 f　在所有窗口中查找关键词，便于窗口多了切换  面板操作（pane）  “　将当前面板上下分屏 %　将当前面板左右分屏 x　关闭当前分屏 !　将当前面板置于新窗口, 即新建一个窗口, 其中仅包含当前面板 Ctrl + 方向键　以 1 个单元格为单位移动边缘以调整当前面板大小 Alt + 方向键　以 5 个单元格为单位移动边缘以调整当前面板大小 空格键　可以在默认面板布局中切换，试试就知道了 q　显示面板编号 o　选择当前窗口中下一个面板 方向键　移动光标选择对应面板 {　向前置换当前面板 }　向后置换当前面板 Alt+o　逆时针旋转当前窗口的面板 Ctrl+o　顺时针旋转当前窗口的面板 z　tmux 1.8 新特性，最大化当前所在面板  Tmux 便捷配置 配置文件 1 2  #新建 Tmux 配置文件 vi $HOME/.tmux.conf   ** 修改 Tmux 快捷键前缀为 ctrl+s，便于操作 **\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #设置前缀 set -g prefix ^s #解除 Ctrl+b 与前缀的对应关系 unbind ^b # split window unbind \u0026#39;\u0026#34;\u0026#39; # vertical split (prefix -) bind - splitw -v unbind % bind | splitw -h # horizontal split (prefix |) #将 r 设置为加载配置文件，并显示 \u0026#34;reloaded!\u0026#34; 信息 bind r source-file ~/.tmux.conf \\; display \u0026#34;Reloaded!\u0026#34; #up bind k select-pane -U #down bind j select-pane -D #left bind h select-pane -L #right bind l select-pane -R #kill pane bind q killp setw -g mode-keys vi   设置 alias 快捷键 1 2 3 4  alias ta=\u0026#39;tmux a -t\u0026#39; alias tf=\u0026#39;tail -f\u0026#39; alias tls=\u0026#39;tmux ls\u0026#39; alias tnew=\u0026#39;tmux new -s\u0026#39;   Oh my tmux 🇫🇷 Oh my tmux! My self-contained, pretty \u0026amp; versatile tmux configuration made with ❤️\nhttps://github.com/gpakosz/.tmux\n更好看、强悍的 tmux 配置，有时间可以研究\n使用 Tips 跳转 Tmux 窗口号为两位数的窗口 通常使用 Prefix + 数字键  可以跳转到指定窗口，但是窗口号如果是 10，当你按下 1 的时候就已经跳转到 1 号窗口了，可以先使用 Prefix + '，然后输入 index\n","date":"2019-08-09T00:00:00Z","permalink":"https://aladdinding.cn/post/tmux-%E7%9A%84-quickstart/","title":"Tmux 的 QuickStart"},{"content":"进入 Vim    命令 描述     vim filename 打开或新建文件，并将光标置于第一行首   vim +n filename 打开文件，并将光标置于第 n 行首   vim + flename 打开文件, 并将光标置于最后一 - 行首   vim +/pattern filename 打开文件, 并将光标置于第一一个 与 pattern 匹配的串处   vim -r filename 在上次正用 vim 编辑时发生系统崩溃，恢复 flename   vim filename\u0026hellip; filename 打开多个文件, 依次编辑    Vim 配置    命令 描述     all 列出所有选项设置情况   term 设置终端类型   ignorance 在搜索中忽略大小写   list 显示制表位 (Ctrl+I) 和行尾标志( $)   number 显示行号   report 显示由面向行的命令修改过的数目   terse 显示简短的警告信息   warn 在转到别的文件时若没保存当前文件则显示 NO write 信息   nomagic 允许 vi 显示其他用户用 write 写到自己终端上的信息   nowrapscan 禁止 vi 在搜索到达文件两端时，又从另 - - 端开始   mesg 允许 vi 显示其他用户用 write 写到自己终端上的信息   :set number/ set nonumber 显示 / 不显示行号   :set ruler /set noruler 显示不显示标尺   :set hlsearch 高亮显示查找到的单词   :sset nohlsearch 关闭高亮显示   :set nu 显示行号   :set tabstop=8 设置 tab 大小，8 为最常用最普遍的设置   :set softabstop=8 4:4 个空格, 8: 正常的制表符，12: 一一个制表符 4 个空格，16: 两个   :set autoindent 自动缩进   :set cindent C 语言格式里面的自动缩进    移动光标    命令 描述     k nk 上向上移动 n 行   j nj 下向下移动 n 行   h nh 左向左移动 n 行   I nl 右向右移动 n 行   Space 光标右移一个字符   Backspace 光标左移一个字符   Enter 光标下移一行   w/W 光标右移一个字至字首   b/B 光标左移一个字至字首   e 或 E 光标右移一个字至字尾   ) 光标移至句尾   ( 光标移至句首   } 光标移至句首   { 光标移至段落结尾   n$ 光标移至第 n 行尾   H 光标移至屏幕顶行   M 光标移至屏幕中间行   L 光标移至屏幕最后行   0 (注意是数字零) 光标移至当前行首   ^ 移动光标到行首第一个非空字符上去   $ 光标移至当前行尾   gg 移到第一行   G 移到最后一行   f 移动光标到当前行的字符 a 上   F 相反   % 移动到与制匹配的括号上去 () ,{},[],\u0026lt;\u0026gt; 等   nG 移动到第 n 行上   G 到最后一行    屏幕滚动    命令 描述     Ctrl+u 向文件首翻半屏   Ctrl+d 向文件尾翻半屏   Ctrl+f 向文件尾翻一屏   Ctrl+ b 向文件首翻一屏   nz 将第 n 行滚至屏幕顶部, 不指定 n 时将当前行滚至屏幕顶部    插入文本类    命令 描述     i 在光标前   I 在当前行首   a 光标后   A 在当前行尾   o 在当前行之下新开一行   O 在当前行之上新开一行   r 替换当前字符   R 替换当前字符及其后的字符, 直至按 ESC 键   s 从当前光标位置处开始, 以输入的文本替代指定数目的字符   S 删除指定数目的行, 并以所输入文本代替之   ncw/nCW 修改指定数目的字   nCC 修改指定数目的行    删除命令    命令 描述     x/X 删除 - 个字符, x 删除光标后的, 而 X 删除光标前的   dw 删除一个单词 (删除光标位置到下一个单词开始的位置)   dnw 删除 n 个单词   dne 也可，只是删除到单词尾   do 删至行首   d$ 删至行尾   dd 删除一行   ndd 删除当前行及其后 n-1 行   dnl 向右删除 n 个字母   dnh 向左删除 n 个字母   dnj 向下删除 n 行，当前行 + 其上 n 行   dnk 向上删除 n 行，当期行 + 其下 n 行   cnw[word] 将 n 个 word 改变为 word   C$ 改变到行尾   cc 改变整行   shift+j 删除行尾的换行符，下一行接上来了    复制粘贴    命令 描述     p 粘贴用 x 或 d 删除的文本   ynw 复制 n 个单词   yy 复制一行   ynl 复制 n 个字符   y$ 复制当前光标至行尾处   Nay 拷贝 n 行    撤销    命令 描述     u 撤销前一 - 次的操作   shif+u(U) 撤销对该行的所有操作    搜索及替换    命令 描述     /pattern 从光标开始处向文件尾搜索 pattern   ?pattern 从光标开始处向文件首搜索 pattern   n 在同 - - 方向重复上 - - 次搜索命令   N 在反方向上重复上一 - 次搜索命令   cw newword 替换为 newword   n 继续查找   . 执行替换   :s/p1/p2/g 将当前行中所有 p1 均用 p2 替代，g 表示执行用 c 表示需要确认   :n1,n2 s/p1/p2/g 将第 n1 至 n2 行中所有 p1 均用 p2 替代   :g/p1/s//p2/g 将文件中所有 p1 均用 p2 替换   :1,$ s/string1/string2/g 在全 文中将 string1 替换为 string2    书签    命令 描述     m[a-z] 在文中做标记, 标记号可为 a-z 的 26 个字母   `a 移动到标记 a 处    visual 模式    命令 描述     v 进入 visual 模式   V 进入行的 visual 模式   ctrl+v 进如块操作模式用 o 和 O 改变选择的边的大小   在所有行插入相同的内容如 include\u0026lt; 将光标移到开始插入的位置，按 CTRL+V 进入 VISUAL 模式 ,选择好模块后按 I（shift+i），后插入要插入的文本，按 [ESC] 完成    行方式命令    命令 描述     :n1,n2 co n3 将 n1 行到 n2 行之间的内容拷贝到第 n3 行下   :n1,n2 m n3 将 n1 行到 n2 行之间的内容移至到第 n3 行下   :n1,n2 d 将 n1 行到 n2 行之间的内容删除   :n1 ,n2 w!command 将文件中 n1 行至 n2 行的内容作为 command 的输入并执行之    若不指定 n1，n2，则表示将整个文件内容作为 command 的输入\n宏    命令 描述     q[a-z] 开始记录但前开始的操作为宏 , 名称可为 [a-z] , 然后用 q 终止录制宏   reg 显示当前定义的所有的宏, 用 @[a-z] 来在当前光标处执行宏 [a-z]    窗口操作    命令 描述     :split 分割一个窗口   :split file.c 为另一个文件 file c 分隔窗口   :nsplit file.c 为另一个文件 file c 分隔窗口, 并指定其行数   ctrl+w 在窗口中切换   :close 关闭当前窗口    文件及其他    命令 描述     :q 退出 vi   :q! 不保存文件并退出 vi   :e filename 打开文件 filename 进行编辑   e! 放弃修改文件内容, 重新载入该文件编辑   :w 保存当前文件   :wq 存盘退出   :ZZ 保存当前文档并退出 Vim   :!command 执行 shell 命令 command   :rlcommand 将命令 command 的输出结果放到当前行   :n1 ,n2 write temp.c    :read file.c 将文件 file.c 的内容插入到当前光标所在的下面    ","date":"2019-08-09T00:00:00Z","permalink":"https://aladdinding.cn/post/vim-%E6%93%8D%E4%BD%9C%E9%80%9F%E6%9F%A5/","title":"Vim 操作速查"}]